<pre class="metadata">
Shortname: webxrlayers-1
Title: WebXR Layers API Level 1
Group: immersivewebwg
Status: w3c/ED
TR:
ED:
Previous Version:
Repository: immersive-web/layers
Level: 1
Mailing List Archives: https://lists.w3.org/Archives/Public/public-immersive-web/

Editor: Rik Cabanier, Facebook https://oculus.com, cabanier@fb.com

Abstract: This specification describes support for accessing the geometry of real world objects during a WebXR session.
</pre>

<pre class="link-defaults">
spec:infra;
    type: dfn; text:string
spec: webxr-1;
    type: dfn; text: immersive xr device; for: XR
    type: dfn; text: xr device; for: /
    type: dfn; text: active; for: XRFrame
    type: dfn; text: eye; for: XRView
    type: dfn; text: initialize the render state
    type: dfn; text: active render state
    type: dfn; text: pending render state
    type: dfn; text: apply the pending render state
    type: dfn; text: viewer reference space
    type: dfn; text: animationFrame; for: XRFrame
    type: dfn; text: feature descriptor
    type: dfn; text: type; for: XRReferenceSpace
    type: dfn; text: session; for: XRSpace
    type: dfn; text: XRLayer
    type: dfn; text: updateRenderState; for: XRSession
    type: dfn; text: session; for: XRWebGLLayer
    type: dfn; text: layers; for: XRRenderStateInit
</pre>

<pre class="anchors">
spec: WebXR Device API - Level 1; urlPrefix: https://www.w3.org/TR/webxr/#
    type: dfn; text: feature descriptor
    type: dfn; text: xr compositor
    type: dfn; text: recommended WebGL framebuffer resolution
    type: dfn; text: native WebGL framebuffer resolution
    type: dfn; text: immersive session
    type: dfn; text: xr compatible
    type: dfn; text: ended
    type: dfn; text: context
    type: dfn; text: XRFrame/active
    type: dfn; text: XRView/active
    type: dfn; text: eye; for: XRView
    type: dfn; text: frame
    type: dfn; text: XRSession/requestAnimationFrame()
spec: WebGL; urlPrefix: https://www.khronos.org/registry/webgl/specs/latest/1.0/
    type: interface; text: WebGLFramebuffer; url: WebGLFramebuffer
    type: interface; text: WebGLTexture; url: WebGLTexture
    type: interface; text: WebGLRenderingContext; url: WebGLRenderingContext
    type: interface; text: WebGLRenderingContextBase; url: WebGLRenderingContextBase
    type: interface; text: GLenum
    type: typedef; text: TEXTURE_2D; url: 5.14
    type: typedef; text: TEXTURE_CUBE_MAP; url: 5.14
spec: WebGL 2.0; urlPrefix: https://www.khronos.org/registry/webgl/specs/latest/2.0/
    type: interface; text: WebGL2RenderingContext; url: WebGL2RenderingContext
    type: typedef; text: TEXTURE_2D_ARRAY; url: 3.7
spec: WEBGL_depth_texture; urlPrefix: https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/
    type: typedef; text: WEBGL_depth_texture
</pre>

<pre class=link-defaults>
    spec:webxr-ar-module-1; type:enum-value; text:"immersive-ar"
</pre>

<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">

<style>
  .unstable::before {
    content: "This section is not stable";
    display: block;
    font-weight: bold;
    text-align: right;
    color: red;
  }
  .unstable {
    border: thin solid pink;
    border-radius: .5em;
    padding: .5em;
    margin: .5em calc(-0.5em - 1px);
    background-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='300' height='290'><text transform='rotate(-45)' text-anchor='middle' font-family='sans-serif' font-weight='bold' font-size='70' y='210' opacity='.1'>Unstable</text></svg>");
    background-repeat: repeat;
    background-color: #FFF4F4;
  }
  .unstable h3:first-of-type {
    margin-top: 0.5rem;
  }

  .unstable.example:not(.no-marker)::before {
    content: "Example " counter(example) " (Unstable)";
    float: none;
  }

  .non-normative::before {
    content: "This section is non-normative.";
    font-style: italic;
  }
  .tg {
    border-collapse: collapse;
    border-spacing: 0;
  }
  .tg th {
    border-style: solid;
    border-width: 1px;
    background: #90b8de;
    color: #fff;
    font-family: sans-serif;
    font-weight: bold;
    border-color: grey;
  }
  .tg td {
    padding: 4px 5px;
    background-color: rgb(221, 238, 255);
    font-family: monospace;
    border-style: solid;
    border-width: 1px;
    border-color: grey;
    overflow: hidden;
    word-break: normal;
  }
</style>

Introduction {#intro}
============

<section class="non-normative">

The spec adds support of `composition` layers to the WebXR spec. The benefits of layers are as follows:

 * <b>Performance and judder</b> Composition layers are presented at the frame rate of the compositor (i.e. native refresh rate of HMD) rather than at the application frame rate.
    Even when the application is not updating the layer's rendering at the native refresh rate of the compositor, the compositor might be able to re-project the existing
    rendering to the proper pose. This results in smoother rendering and less judder. Another feature of layers is that each of them can have different resolution. This allows the
    application to scale down the main eye buffer resolution on low performance systems, but keeping essential information, such as text or a map, in its own layer at a higher
    resolution.

 * <b>Legibility/visual fidelity</b> The resolution for eye-buffers for 3D world rendering can be set to relatively low values especially on low performance systems. It would
    be impossible to render high fidelity content, such as text, in this case. Each layer may have its own resolution and it will be re-sampled only once by the compositor (in contrary
    to the traditional approach with rendering layers via WebGL where the layer's content got re-sampled at least twice: once when rendering into WebGL
    eye-buffer (and losing a lot of details due to limited eye-buffer resolution) and the second time by the compositor).

 * <b>Power consumption / battery life</b> Due to reduced rendering pipeline, the lack of double sampling and no need to update the layer's rendering each frame, the power
    consumption is expected to be improved.

 * <b>Latency</b> Pose sampling for composition layers may occur at the very end of the frame and then certain reprojection techniques could be used to update the layer's pose to
    match it with the most recent HMD pose. This may significantly reduce the effective latency for the layers' rendering and as a result improve overall experience.

ISSUE: how to do hit testing? Should it be done by the UA?

</section>


Terminology {#terminology}
-----------

Application flow {#applicationflow}
----------------

<section class="non-normative">

If an author wants to use layers, they have to go through these steps:
 1. request support through {{XRPermissionDescriptor/requiredFeatures}} or {{XRPermissionDescriptor/optionalFeatures}} in {{XRSystem/requestSession()}}
 1. create a {{XRWebGLBinding}} or {{XRMediaBinding}}
 1. create layers with these objects
 1. add the layers to {{XRRenderStateInit}} and call {{XRSession/updateRenderState()}}
 1. during {{XRSession/requestAnimationFrame()}} for webgl layers, draw content each gl layer

</section>

Model {#model}
=====

In order for the applications to signal their interest in using layers during a session,
the session MUST be requested with an appropriate [=feature descriptor=]. The string <dfn for="feature descriptor">layers</dfn> is introduced
by this module as a new valid [=feature descriptor=] for WebXR Layers feature.

<div class="example">
The following code requests layers as an optional feature.

<pre highlight="js">
navigator.xr.requestSession('immersive-vr', {
    optionalFeatures: ['layers']
  }
</pre>
</div>

Layers are only supported for XRSessions created with XRSessionMode of {{XRSessionMode/"immersive-vr"}}
or {{XRSessionMode/"immersive-ar"}}. {{XRSessionMode/"inline"}} sessions MUST not support layers.

Layer types {#xrlayertypes}
===========

Mono and stereo layers {#monovsstereo}
----------------------
A stereo layer MUST supply a different view to render to for each eye. Stereo layers should be refreshed
close to the device's native frame rate.

A mono layer MUST supply a single view which is shown to each eye. There is no requirement to refresh mono
layers repeatedly.

The [=XR Compositor=] MUST ensure that layers are presented correctly in stereo to the observer.

XRLayerLayout {#xrlayerlayouttype}
-------------
The {{XRLayerLayout}} enum defines the layout of the layer.

<pre class="idl">
enum XRLayerLayout {
  "mono",
  "stereo",
  "stereo-left-right",
  "stereo-top-bottom"
};
</pre>

 - A layout of <dfn enum-value for="XRLayerLayout">mono</dfn> indicates that the layer is mono.
 - A layout of <dfn enum-value for="XRLayerLayout">stereo</dfn> indicates that the layer is in stereo. It's left to the user agent what layout to use.
 - A layout of <dfn enum-value for="XRLayerLayout">stereo-left-right</dfn> indicates that the layer is in stereo and divided left to right.
 - A layout of <dfn enum-value for="XRLayerLayout">stereo-top-bottom</dfn> indicates that the layer is in stereo and divided top to bottom.

 NOTE: If an {{XRCompositionLayer}} is created with an {{XRLayerLayout/"stereo"}} layout, it is highly recommended that it is allocated with an {{XRTextureType/"texture-array"}} texture type.

XRCompositionLayer {#xrcompositionlayertype}
--------------
XRCompositionLayer defines a set of common attributes and behaviors across certain layer types.

<pre class="idl">
interface XRCompositionLayer : XRLayer {
  readonly attribute XRLayerLayout layout;
  readonly attribute unsigned long pixelWidth;
  readonly attribute unsigned long pixelHeight;

  attribute boolean blendTextureSourceAlpha;
  attribute boolean chromaticAberrationCorrection;

  void destroy();
};
</pre>

The <dfn attribute for="XRCompositionLayer">layout</dfn> attribute returns the layout of the layer.

The <dfn attribute for="XRCompositionLayer">pixelWidth</dfn> and <dfn attribute for="XRCompositionLayer">pixelHeight</dfn> attributes
return the width and height of the GL attachments, respectively. If there are no attachments, they will return 0.

The <dfn attribute for="XRCompositionLayer">blendTextureSourceAlpha</dfn> attribute enables the layer’s texture alpha channel.

The <dfn attribute for="XRCompositionLayer">chromaticAberrationCorrection</dfn> attribute is a hint for the [=XR Compositor=] to
enable optical chromatic aberration correction for the layer. Only valid if this isn't done by default.

ISSUE: describe what chromaticAberrationCorrection does.

{{destroy()}} will delete the underlying attachments. If there are no attachments, this function does nothing.

Each {{XRCompositionLayer}} has a <dfn for="XRCompositionLayer">context</dfn> object which is an instance
of either a {{WebGLRenderingContext}} or a {{WebGL2RenderingContext}}.

Each {{XRCompositionLayer}} has an associated <dfn for="XRCompositionLayer">session</dfn>, which is the
{{XRSession}} it was created with.

<div class="algorithm" data-algorithm="setting the space on a layer">

When <dfn>setting the space on a layer</dfn> with {{XRSpace}} |space| and {{XRCompositionLayer}} |layer|, the user agent MUST run the following steps to validate if the |space| is valid:
  1. If |space| is <code>null</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |space|'s [=XRSpace/session=] is not equal to the |layer|'s [=XRCompositionLayer/session=], throw {{InvalidStateError}} and abort these steps.

</div>

XRProjectionLayer {#xrprojectionlayertype}
-----------------
An {{XRProjectionLayer}} is a layer that fills the entire view of the observer.
Projection layers should be refreshed close to the device's native frame rate.

<pre class="idl">
interface XRProjectionLayer : XRCompositionLayer {
  readonly attribute boolean ignoreDepthValues;
};
</pre>

The <dfn attribute for="XRProjectionLayer">ignoreDepthValues</dfn> attribute, if <code>true</code>, indicates that the
[=XR Compositor=] MUST NOT make use of values in the depth buffer attachment when rendering. When the attribute
is <code>false</code> it indicates that the content of the depth buffer attachment will be used by the
[=XR Compositor=] and is expected to be representative of the scene rendered into the layer.

XRQuadLayer {#xrquadlayertype}
-----------
An {{XRQuadLayer}} renders a layer that takes up a flat rectangular space in the virtual environment.
Only the front of the layer MUST be visible; the back face MUST not be drawn by the [=XR Compositor=].

A XRQuadLayer has no thicknes. It is a two-dimensional object positioned and oriented in 3D space. The position
of a quad refers to the center of the quad.

<pre class="idl">
interface XRQuadLayer : XRCompositionLayer {
  attribute XRSpace space;
  attribute XRRigidTransform transform;

  attribute float width;
  attribute float height;
};
</pre>

The <dfn attribute for="XRQuadLayer">transform</dfn> attributes sets and returns the offset and orientation relative to the
<dfn attribute for="XRQuadLayer">space</dfn> attribute. The {{XRQuadLayer/transform}} and {{XRQuadLayer/space}} attributes
establish the spatial relationship of the layer within the user’s physical environment.
When setting the {{XRQuadLayer/space}}, first run the steps for [=setting the space on a layer=].

The <dfn attribute for="XRQuadLayer">width</dfn> and <dfn attribute for="XRQuadLayer">height</dfn> attributes
set and return the width and height of the layer in meters.

XRCylinderLayer {#xrcylinderayertype}
---------------
An {{XRCylinderLayer}} renders a layer that takes up a curved rectangular space in the virtual environment.
Only the front of the layer MUST be visible; the back face MUST not be drawn by the [=XR Compositor=].

A XRCylinderLayer has no thicknes. It is a two-dimensional object positioned and oriented in 3D space. The position
of the cylinder refers to the center of the quad.

<pre class="idl">
interface XRCylinderLayer : XRCompositionLayer {
  attribute XRSpace space;
  attribute XRRigidTransform transform;

  attribute float radius;
  attribute float centralAngle;
  attribute float aspectRatio;
};
</pre>

The <dfn attribute for="XRCylinderLayer">transform</dfn> attribute sets and returns the offset and orientation relative to the
<dfn attribute for="XRCylinderLayer">space</dfn> attribute. The {{XRCylinderLayer/transform}} and {{XRCylinderLayer/space}} attributes
establish the spatial relationship of the layer within the user’s physical environment.
When setting the {{XRCylinderLayer/space}}, first run the steps for [=setting the space on a layer=].

The <dfn attribute for="XRCylinderLayer">radius</dfn> attribute controls the radius in meters of the cylinder.

The <dfn attribute for="XRCylinderLayer">centralAngle</dfn> attribute controls the angle in degrees of the visible section of the cylinder.
It grows symmetrically around the 0 angle.

The <dfn attribute for="XRCylinderLayer">aspectRatio</dfn> attribute controls the ratio of the visible cylinder section.

<img src="images/cylinder_layer_params.png" style="width:80%"/>

XREquirectLayer {#xrequirectlayertype}
---------------
An {{XREquirectLayer}} renders a layer where the [=XR Compositor=] MUST map an equirectangular coded data onto the inside of a sphere.

ISSUE: this section needs clarification

<pre class="idl">
interface XREquirectLayer : XRCompositionLayer {
  attribute XRRigidTransform transform;

  attribute float radius;
  attribute float scaleX;
  attribute float scaleY;
  attribute float biasX ;
  attribute float biasY;
};
</pre>

{{XREquirectLayer}} has an internal <dfn dfn-for="XREquirectLayer">referenceSpace</dfn> which is equal to the {{session}}'s [=viewer reference space=].

The <dfn attribute for="XREquirectLayer">transform</dfn> attribute sets and returns the offset and orientation relative to
[=XREquirectLayer/referenceSpace=]. The {{XREquirectLayer/transform}} attribute and the internal [=XREquirectLayer/referenceSpace=]
establish the spatial relationship of the layer within the user’s physical environment.

The <dfn attribute for="XREquirectLayer">radius</dfn> attribute is the non-negative radius of the sphere. Values of less than or
equal to zero or infinity are treated as an infinite sphere.

The <dfn attribute for="XREquirectLayer">scaleX</dfn> and <dfn attribute for="XREquirectLayer">scaleY</dfn> attributes
set and return a scale of the texture coordinates after the mapping to 2D.

The <dfn attribute for="XREquirectLayer">biasX</dfn> and <dfn attribute for="XREquirectLayer">biasY</dfn> attributes
set and return a bias of the texture coordinates after the mapping to 2D.

XRCubeLayer {#xcubelayertype}
-----------
A {{XRCubeLayer}} renders a layer where the [=XR Compositor=] renders directly from a cubemap.

ISSUE: this section needs clarification

<pre class="idl">
interface XRCubeLayer : XRCompositionLayer {
  attribute XRSpace space;
  attribute DOMPointReadOnly orientation;
};
</pre>

The <dfn attribute for="XRCubeLayer">orientation</dfn> attribute sets and returns the orientation relative to the
<dfn attribute for="XRCubeLayer">space</dfn> attribute. The {{XRCubeLayer/orientation}} and {{XRCubeLayer/space}} attributes
establish the spatial relationship of the layer within the user’s physical environment.
When setting the {{XRCubeLayer/space}}, first run the steps for [=setting the space on a layer=].

Rendering {#rendering}
=========

XRSubImage {#xrsubimagetype}
----------
The {{XRSubImage}} object represents what viewport of the GPU texture to use.

<pre class="idl">
interface XRSubImage {
  readonly attribute XRViewport viewport;
};
</pre>

NOTE: this class is designed to accomodate future extensions

The <dfn attribute for="XRSubImage">viewport</dfn> attribute returns the {{XRViewport}} to use when rendering the sub image.

XRWebGLSubImage {#xrwebglsubimagetype}
---------------
The {{XRWebGLSubImage}} object is used during rendering of the layer.

<pre class="idl">
interface XRWebGLSubImage : XRSubImage {
  readonly attribute WebGLTexture colorTexture;
  readonly attribute WebGLTexture? depthStencilTexture;
  readonly attribute unsigned long? imageIndex;
};
</pre>

The <dfn attribute for="XRWebGLSubImage">colorTexture</dfn> attribute returns the color {{WebGLTexture}} for the {{XRCompositionLayer}}.

The <dfn attribute for="XRWebGLSubImage">depthStencilTexture</dfn> attribute returns the depth/stencil {{WebGLTexture}} for the {{XRCompositionLayer}}.
If the layer was created without depth/stencil, this attribute returns null.

The <dfn attribute for="XRWebGLSubImage">imageIndex</dfn> attribute returns the offset into the texture array. Valid only for layers
that were requested with {{texture-array}}.

This {{XRWebGLSubImage/colorTexture}} and {{XRWebGLSubImage/depthStencilTexture}} are only valid during
{{XRSession/requestAnimationFrame()}} callback and becomes invalid as soon as the callback returns.

XRTextureType {#xrtexturetype}
-------------
The {{XRTextureType}} enum defines what type of texture is allocated.

<pre class="idl">
enum XRTextureType {
  "texture",
  "texture-array"
};
</pre>

- A texture type of <dfn enum-value for="XRTextureType">texture</dfn> indicates that the textures of {{XRWebGLSubImage}} must be of type {{TEXTURE_2D}}
- A texture type of <dfn enum-value for="XRTextureType">texture-array</dfn> indicates that the textures of {{XRWebGLSubImage}} must be of type {{TEXTURE_2D_ARRAY}}

GPU layer and view creation {#gpulayer}
===========================

Overview {#xrgpulayeroverview}
--------
<section class="non-normative">

When a layer is created it is backed by a GPU resource, typically a texture, provided by one of the Web platform's graphics APIs. In order to
specify which API is providing the layer's GPU resources a {{XRWebGLBinding}} for the API in question must be created.
Each graphics API may have unique requirements that must be satisfied before a context can be used in the creation of a layer. For example,
a {{WebGLRenderingContext}} must have its xrCompatible flag set prior to being passed to the constructor of the {{XRWebGLBinding}} instance.

Any interaction between the {{XRSession}} the graphics API, such as allocating or retrieving textures, will go through this {{XRWebGLBinding}} instance, and the exact mechanics
of the interaction will typically be API specific. This allows the rest of the WebXR API to be
graphics API agnostic and more easily adapt to future advances in rendering techniques.

Once a {{XRWebGLBinding}} instance has been acquired, it can be used to create a variety of {{XRCompositionLayer}}. Any layers created by that instance will then be able
to query the associated GPU resources each frame, generally expected to be the native API's texture interface.

The various layer types are created with the create____Layer series of methods on the {{XRWebGLBinding}} instance. Information about the graphics resources required,
such as whether or not to allocate a depth buffer or alpha channel, are passed in at layer creation time and will be immutable for the lifetime of the layer.
The method will return the associated XRCompositionLayer type.

Some layer types may not be supported by the {{XRSession}}. If a layer type isn't supported the method will throw an exception. {{XRProjectionLayer}} MUST be supported by all {{XRSession}}s.
</section>

XRProjectionLayerInit {#xrprojectionlayerinittype}
---------------------
The {{XRProjectionLayerInit}} dictionary represents a set of configurable values that describe how a {{XRProjectionLayer}}
is initialized.

<pre class="idl">
dictionary XRProjectionLayerInit {
  boolean depth = true;
  boolean stencil = false;
  boolean alpha = true;
  double scaleFactor = 1.0;
};
</pre>

The <dfn dict-member for="XRProjectionLayerInit">depth</dfn> attribute defines if the {{XRProjectionLayer}} will have a depth buffer.

The <dfn dict-member for="XRProjectionLayerInit">stencil</dfn> attribute defines if the {{XRProjectionLayer}} will have a stencil buffer.

The <dfn dict-member for="XRProjectionLayerInit">alpha</dfn> attribute defines if the {{XRProjectionLayer}} will have an alpha channel.

The <dfn dict-member for="XRProjectionLayerInit">scaleFactor</dfn> attribute defines the value that the |session|'s
[=recommended WebGL framebuffer resolution=] must be multiplied by determining the resolution of the layer's attachments.

XRLayerInit {#xrlayerinittype}
---------------------
The {{XRLayerInit}} dictionary represents a set of configurable values that describe how {{XRQuadLayer}}, {{XRCylinderLayer}}, {{XREquirectLayer}}
and {{XRCubeLayer}} are initialized.

<pre class="idl">
dictionary XRLayerInit {
  required unsigned long pixelWidth;
  required unsigned long pixelHeight;
  XRLayerLayout layout = "mono";
  boolean depth = false;
  boolean stencil = false;
  boolean alpha = true;
};
</pre>

the <dfn dict-member for="XRLayerInit">pixelWidth</dfn> and <dfn dict-member for="XRLayerInit">pixelHeight</dfn> attributes define
the rectangular dimensions of the {{XRCompositionLayer}}

The <dfn dict-member for="XRLayerInit">layout</dfn> attribute defines the layout of the layer.

The <dfn dict-member for="XRLayerInit">depth</dfn> attribute defines if the {{XRCompositionLayer}} view will have a depth buffer.

The <dfn dict-member for="XRLayerInit">stencil</dfn> attribute defines if the {{XRCompositionLayer}} view will have a stencil buffer.

The <dfn dict-member for="XRLayerInit">alpha</dfn> attribute defines if the {{XRCompositionLayer}} view will have an alpha channel.

XRWebGLBinding {#XRWebGLBindingtype}
-------------------
The {{XRWebGLBinding}} object is used to create layers that have a GPU backend.

<pre class="idl">
interface XRWebGLBinding {
  constructor(XRSession session, XRWebGLRenderingContext context);

  readonly attribute double nativeProjectionScaleFactor;

  XRProjectionLayer createProjectionLayer(XRTextureType textureType,
                                          optional XRProjectionLayerInit init);
  XRQuadLayer createQuadLayer(XRTextureType textureType,
                              XRLayerInit init);
  XRCylinderLayer createCylinderLayer(XRTextureType textureType,
                                      XRLayerInit init);
  XREquirectLayer createEquirectLayer(XRTextureType textureType,
                                      XRLayerInit init);
  XRCubeLayer createCubeLayer(XRLayerInit init);

  XRWebGLSubImage getSubImage(XRCompositionLayer layer, XRFrame frame);
  XRWebGLSubImage getViewSubImage(XRCompositionLayer layer, XRView view);
};
</pre>

Each {{XRWebGLBinding}} has a <dfn dfn-for="XRWebGLBinding">context</dfn> object of type {{XRWebGLRenderingContext}} which is an instance
of either a {{WebGLRenderingContext}} or a {{WebGL2RenderingContext}}.

Each {{XRWebGLBinding}} has an associated <dfn dfn-for="XRWebGLBinding">session</dfn>, which is the
{{XRSession}} it was created with.

NOTE: It is possible to create more than one {{XRWebGLBinding}}. Any layer created with an instance of {{XRWebGLBinding}} can
be used with another instance of {{XRWebGLBinding}} as long as both were created with the same {{session}} and the same
{{context}}. The lifetime of layers or instances of {{XRWebGLSubImage}} is not tied to the lifetime of the {{XRWebGLBinding}} that created them.

Each {{XRCompositionLayer}} created through {{XRWebGLBinding}} has an internal <dfn>colorTextures</dfn> array which is an |array| of {{WebGLTexture}} for color textures and
an internal <dfn>depthStencilTextures</dfn> which is an |array| of {{WebGLTexture}}</dfn> for depth/stencil textures.

<div class="algorithm" data-algorithm="construct-webgl-layer">

The <dfn constructor for="XRWebGLBinding">XRWebGLBinding(|session|, |context|)</dfn> constructor
MUST perform the following steps when invoked:

  1. Let |binding| be a new {{XRWebGLBinding}}
  1. If |session|'s [=ended=] value is <code>true</code>, throw an {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw an {{InvalidStateError}} and abort these steps.
  1. If |session| is not an [=immersive session=], throw an {{InvalidStateError}} and abort these steps.
  1. If |context|'s [=XR compatible=] boolean is <code>false</code>, throw an {{InvalidStateError}} and abort these steps.
  1. Initialize |binding|'s {{context}} to |context|.
  1. Initialize |binding|'s {{session}} to |session|.
  1. Return |binding|.

</div>

The {{nativeProjectionScaleFactor}} function returns the value that the |session|'s [=recommended WebGL framebuffer resolution=]
MUST be multiplied by to yield the |session|'s [=native WebGL framebuffer resolution=].

<div class="algorithm" data-algorithm="determine the layout attribute">

To <dfn>determine the layout attribute</dfn> using a {{XRTextureType}} |textureType|, a {{XRWebGLRenderingContext}} |context| and a {{XRLayerInit}} |init|, the user agent MUST run the following steps:
  1. If |textureType| is {{"cubemap-texture"}}, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is not a {{WebGL2RenderingContext}} and |textureType| is {{"texture-array"}}, throw {{InvalidStateError}} and abort these steps.
  1. let |layout| be |init|'s {{XRLayerInit/layout}}.
  1. If |layout| is {{XRLayerLayout/"mono"}}, return |layout| and abort these steps.
  1. If |layout| is {{XRLayerLayout/"stereo"}}, run the following steps:
    1. If |textureType| is {{"texture-array"}}, return |layout| and abort these steps.
    1. If the user agent prefers {{XRLayerLayout/"stereo-left-right"}} layout, return {{XRLayerLayout/"stereo-left-right"}} and abort these steps.
    1. If the user agent prefers {{XRLayerLayout/"stereo-top-bottom"}} layout, return {{XRLayerLayout/"stereo-top-bottom"}} and abort these steps.
  1. If |textureType| is {{"texture-array"}}, throw {{InvalidStateError}} and abort these steps.
  1. return |layout|.

</div>

ISSUE: special case UA behavior if the size causes the layout to change (ie if the requested width exceeds a limit with {{XRLayerLayout/"stereo-left-right"}})

<div class="algorithm" data-algorithm="allocate color textures">

To <dfn>allocate color textures</dfn> using a {{XRLayerInit/layout}} |layout|, a {{XRTextureType}} |textureType|, a {{XRWebGLRenderingContext}} |context| and a {{XRLayerInit}} |init|, the user agent MUST run the following steps:
  1. let |array| be a new array.
  1. If |layout| is {{XRLayerLayout/mono}}:
        <dl class="switch">
        <dt> If |textureType| is {{"texture-array"}}:
          <dd> Initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_2D_ARRAY}} texture with 1 internal texture using |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/pixelWidth}} and {{XRLayerInit/pixelHeight}} values.
        <dt> Otherwise
          <dd> Initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_2D}} texture with |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/pixelWidth}} and {{XRLayerInit/pixelHeight}} values.
        <dl>
  1. If |layout| is {{XRLayerLayout/stereo}}:
        <dl class="switch">
        <dt> If |textureType| is {{"texture-array"}}:
          <dd> Initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_2D_ARRAY}} texture with 2 internal textures using |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/pixelWidth}} and {{XRLayerInit/pixelHeight}} values.
          <dd> Return |array| and abort these steps.
        <dt> Otherwise
          <dd> Initialize |array| with 2 new instances of {{WebGLTexture}} created as a {{TEXTURE_2D}} texture with |context| and |init|'s {{XRProjectionLayerInit/alpha}}, {{XRLayerInit/pixelWidth}} and {{XRLayerInit/pixelHeight}} values.
          <dd> Return |array| and abort these steps.
        </dl>
  1. If |layout| is {{XRLayerLayout/stereo-left-right}}, initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_2D}} texture using |context| and |init|'s {{XRLayerInit/alpha}}, double of {{XRLayerInit/pixelWidth}} and {{XRLayerInit/pixelHeight}} values.
  1. If |layout| is {{XRLayerLayout/stereo-top-bottom}}, initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_2D}} texture using |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/pixelWidth}} and double of {{XRLayerInit/pixelHeight}} values.
  1. return |array|.

</div>

<div class="algorithm" data-algorithm="allocate depth textures">

To <dfn>allocate depth textures</dfn> using a {{XRLayerInit/layout}} |layout|, a {{XRTextureType}} |textureType|, a {{XRWebGLRenderingContext}} |context| and a {{XRLayerInit}} |init|, the user agent MUST run the following steps:
  1. let |array| be a new array.
  1. If |init|'s {{XRLayerInit/depth}} and {{XRLayerInit/stencil}} are not set, return |array| and abort these steps.
  1. let |depthsupport| be true if |context| is a {{WebGL2RenderingContext}} or the {{WEBGL_depth_texture}} extension is enabled in |context|.
  1. If |init|'s {{XRLayerInit/depth}} or {{XRLayerInit/stencil}} are set and |depthsupport| is false, throw {{InvalidStateError}} and abort these steps.
  1. If |layout| is {{XRLayerLayout/mono}}:
        <dl class="switch">
        <dt> If |textureType| is {{"texture-array"}}:
        <dd> Initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_2D_ARRAY}} texture with 1 internal texture using |context| and |init|'s {{XRLayerInit/stencil}}, {{XRLayerInit/pixelWidth}} and {{XRLayerInit/pixelHeight}} values.
        <dt> Otherwise
        <dd> Initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_2D}} texture with |context| and |init|'s {{XRLayerInit/stencil}}, {{XRLayerInit/pixelWidth}} and {{XRLayerInit/pixelHeight}} values.
  1. If |layout| is {{XRLayerLayout/stereo}}:
        <dl class="switch">
        <dt> If |textureType| is {{"texture-array"}}:
        <dd> Initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_2D_ARRAY}} texture with 2 internal textures using |context| and |init|'s {{XRLayerInit/stencil}}, {{XRLayerInit/pixelWidth}} and {{XRLayerInit/pixelHeight}} values.
        <dd> Return |array| and abort these steps.
        <dt> Otherwise
        <dd> Initialize |array| with 2 new instances of {{WebGLTexture}} created as a {{TEXTURE_2D}} texture with |context| and |init|'s {{XRLayerInit/stencil}}, {{XRLayerInit/pixelWidth}} and {{XRLayerInit/pixelHeight}} values.
        <dd> Return |array| and abort these steps.
        </dl>
  1. If |layout| is {{XRLayerLayout/stereo-left-right}}, initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_2D}} texture using |context| and |init|'s {{XRLayerInit/stencil}}, double of {{XRLayerInit/pixelWidth}} and {{XRLayerInit/pixelHeight}} values.
  1. If |layout| is {{XRLayerLayout/stereo-top-bottom}}, initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_2D}} texture using |context| and |init|'s {{XRLayerInit/stencil}}, {{XRLayerInit/pixelWidth}} and double of {{XRLayerInit/pixelHeight}} values.
  1. return |array|.

</div>

<div class="algorithm" data-algorithm="createProjectionLayerAlgo">
The <dfn method for="XRWebGLBinding">createProjectionLayer(XRTextureType |textureType|, optional XRProjectionLayerInit |init|)</dfn> method creates a new {{XRProjectionLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. Let |session| be the target {{XRWebGLBinding}}'s {{session}}.
  1. Let |context| be the target {{XRWebGLBinding}}'s {{context}}.
  1. Let |bufferSize| be the [=recommended WebGL framebuffer resolution=] multiplied by |init|'s {{XRProjectionLayerInit/scaleFactor}}.
  1. Let |layer| be a new {{XRProjectionLayer}}
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw {{InvalidStateError}} and abort these steps.
  1. Initialize |layer|'s [=XRCompositionLayer/context=] to |context|.
  1. Initialize |layer|'s [=XRCompositionLayer/session=] to |session|.
  1. Initialize |layer|'s {{XRProjectionLayer/ignoreDepthValues}} as follows:
      <dl class="switch">
      <dt> If |init|'s {{XRProjectionLayerInit/depth}} value is <code>false</code> and the [=XR Compositor=] will make use of depth values
      <dd> Initialize |layer|'s {{XRProjectionLayer/ignoreDepthValues}} to <code>false</code>
      <dt> Otherwise
      <dd> Initialize |layer|'s {{XRProjectionLayer/ignoreDepthValues}} to <code>true</code>
      </dl>
  1. let |helperInit| be a new {{XRLayerInit}}.
  1. Initialize |helperInit|'s {{XRLayerInit/pixelWidth}} to |bufferSize| width.
  1. Initialize |helperInit|'s {{XRLayerInit/pixelHeight}} to |bufferSize| height.
  1. Initialize |helperInit|'s {{XRLayerInit/layout}} to {{XRLayerLayout/"stereo"}}
  1. Initialize |helperInit|'s {{XRLayerInit/depth}} to |init|'s {{XRProjectionLayerInit/depth}}.
  1. Initialize |helperInit|'s {{XRLayerInit/stencil}} to |init|'s {{XRProjectionLayerInit/stencil}}.
  1. Initialize |helperInit|'s {{XRLayerInit/alpha}} to |init|'s {{XRProjectionLayerInit/alpha}}.
  1. let |layout| be the result of [=determine the layout attribute|determining the layout attribute=] with |textureType|, |context| and |helperInit|.
  1. Initialize |layer|'s {{XRCompositionLayer/layout}} to |layout|.
  1. let |layer|'s [=colorTextures=] be the result of [=allocate color textures|allocating color textures=] with |layout|, |textureType|, |context| and |helperInit|.
  1. let |layer|'s [=depthStencilTextures=] be the result of [=allocate depth textures|allocating depth textures=] with |layout|, |textureType|, |context| and |helperInit|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. Return |layer|.

</div>

ISSUE: define "opaque" {{WebGLTexture}}

<div class="algorithm" data-algorithm="createQuadLayerAlgo">
The <dfn method for="XRWebGLBinding">createQuadLayer(XRTextureType |textureType|, XRLayerInit |init|)</dfn> method creates a new {{XRQuadLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. If the device does not support the creation of an {{XRQuadLayer}}, throw an {{NotSupportedError}} and abort these steps.
  1. Let |session| be the target {{XRWebGLBinding}}'s [=XRWebGLBinding/session=].
  1. Let |context| be the target {{XRWebGLBinding}}'s [=XRWebGLBinding/context=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw {{InvalidStateError}} and abort these steps.
  1. Let |layer| be a new {{XRQuadLayer}}.
  1. Initialize |layer|'s [=XRCompositionLayer/context=] to |context|.
  1. Initialize |layer|'s [=XRCompositionLayer/session=] to |session|.
  1. Initialize |layer|'s {{XRQuadLayer/width}} to <code>1.0f</code>.
  1. Initialize |layer|'s {{XRQuadLayer/height}} to <code>1.0f</code>.
  1. Let |layer|'s {{XRQuadLayer/space}} be the {{session}}'s [=viewer reference space=].
  1. Let |layer|'s {{XRQuadLayer/transform}} be a new {{XRRigidTransform}} initialized with a {{DOMPointInit}} position of <code>{ x: 1.0, y: 0.0, z: 0.0, w: 1.0 }</code>.
  1. let |layout| be the result of [=determine the layout attribute|determining the layout attribute=] with |textureType|, |context| and |init|.
  1. Initialize |layer|'s {{XRCompositionLayer/layout}} to |layout|.
  1. let |layer|'s [=colorTextures=] be the result of [=allocate color textures|allocating color textures=] with |layout|, |textureType|, |context| and |init|.
  1. let |layer|'s [=depthStencilTextures=] be the result of [=allocate depth textures|allocating depth textures=] with |layout|, |textureType|, |context| and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

<div class="algorithm" data-algorithm="createCylinderLayerAlgo">
The <dfn method for="XRWebGLBinding">createCylinderLayer(XRTextureType |textureType|, XRLayerInit |init|)</dfn> method creates a new {{XRCylinderLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. If the device does not support the creation of an {{XRCylinderLayer}}, throw an {{NotSupportedError}} and abort these steps.
  1. Let |session| be the target {{XRWebGLBinding}}'s [=XRWebGLBinding/session=].
  1. Let |context| be the target {{XRWebGLBinding}}'s [=XRWebGLBinding/context=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw {{InvalidStateError}} and abort these steps.
  1. Let |layer| be a new {{XRCylinderLayer}}.
  1. Initialize |layer|'s [=XRCompositionLayer/context=] to |context|.
  1. Initialize |layer|'s [=XRCompositionLayer/session=] to |session|.
  1. Initialize |layer|'s {{XRCylinderLayer/radius}} to <code>2.0f</code>.
  1. Initialize |layer|'s {{XRCylinderLayer/centralAngle}} to <code>45.0f</code>.
  1. Initialize |layer|'s {{XRCylinderLayer/aspectRatio}} to <code>2.0f</code>.
  1. Let |layer|'s {{XRCylinderLayer/space}} be the {{session}}'s [=viewer reference space=].
  1. Let |layer|'s {{XRCylinderLayer/transform}} be a new {{XRRigidTransform}}.
  1. let |layout| be the result of [=determine the layout attribute|determining the layout attribute=] with |textureType|, |context| and |init|.
  1. Initialize |layer|'s {{XRCompositionLayer/layout}} to |layout|.
  1. let |layer|'s [=colorTextures=] be the result of [=allocate color textures|allocating color textures=] with |layout|, |textureType|, |context| and |init|.
  1. let |layer|'s [=depthStencilTextures=] be the result of [=allocate depth textures|allocating depth textures=] with |layout|, |textureType|, |context| and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

<div class="algorithm" data-algorithm="createEquirectLayerAlgo">
The <dfn method for="XRWebGLBinding">createEquirectLayer(XRTextureType |textureType|, XRLayerInit |init|)</dfn> method creates a new {{XREquirectLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. If the device does not support the creation of an {{XREquirectLayer}}, throw an {{NotSupportedError}} and abort these steps.
  1. Let |session| be the target {{XRWebGLBinding}}'s [=XRWebGLBinding/session=].
  1. Let |context| be the target {{XRWebGLBinding}}'s [=XRWebGLBinding/context=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw {{InvalidStateError}} and abort these steps.
  1. Let |layer| be a new {{XREquirectLayer}}.
  1. Initialize |layer|'s [=XRCompositionLayer/context=] to |context|.
  1. Initialize |layer|'s [=XRCompositionLayer/session=] to |session|.
  1. Initialize |layer|'s {{XREquirectLayer/radius}} to <code>10.0f</code>.
  1. Initialize |layer|'s {{XREquirectLayer/scaleX}} to <code>1.0f</code>.
  1. Initialize |layer|'s {{XREquirectLayer/scaleY}} to <code>1.0f</code>.
  1. Initialize |layer|'s {{XREquirectLayer/biasX}} to <code>0.0f</code>.
  1. Initialize |layer|'s {{XREquirectLayer/biasY}} to <code>0.0f</code>.
  1. Let |layer|'s [=XREquirectLayer/space=] be the {{session}}'s [=viewer reference space=].
  1. Let |layer|'s {{XREquirectLayer/transform}} be a new {{XRRigidTransform}}.
  1. let |layout| be the result of [=determine the layout attribute|determining the layout attribute=] with |textureType|, |context| and |init|.
  1. Initialize |layer|'s {{XRCompositionLayer/layout}} to |layout|.
  1. let |layer|'s [=colorTextures=] be the result of [=allocate color textures|allocating color textures=] with |layout|, |textureType|, |context| and |init|.
  1. let |layer|'s [=depthStencilTextures=] be the result of [=allocate depth textures|allocating depth textures=] with |layout|, |textureType|, |context| and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

<div class="algorithm" data-algorithm="createCubeLayerAlgo">
The <dfn method for="XRWebGLBinding">createCubeLayer(XRLayerInit |init|)</dfn> method creates a new {{XRCubeLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. If the device does not support the creation of an {{XRCubeLayer}}, throw an {{NotSupportedError}} and abort these steps.
  1. Let |session| be the target {{XRWebGLBinding}}'s [=XRWebGLBinding/session=].
  1. Let |context| be the target {{XRWebGLBinding}}'s [=XRWebGLBinding/context=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is not a {{WebGL2RenderingContext}} context, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw {{InvalidStateError}} and abort these steps.
  1. Let |layer| be a new {{XRCubeLayer}}.
  1. Initialize |layer|'s [=XRCompositionLayer/context=] to |context|.
  1. Initialize |layer|'s [=XRCompositionLayer/session=] to |session|.
  1. Let |layer|'s {{XRCubeLayer/space}} be the {{session}}'s [=viewer reference space=].
  1. Let |layer|'s {{XRCubeLayer/orientation}} be a new {{DOMPointReadOnly}}.
  1. let |layout| be |init|'s {{XRLayerInit/layout}}.
  1. If |layout| is {{XRLayerLayout/"stereo-left-right"}} or {{XRLayerLayout/"stereo-top-bottom"}}, throw {{InvalidStateError}} and abort these steps.
  1. Initialize |array| as follows:
    <dl class="switch">
      <dt> {{XRLayerLayout/"mono"}}:
        <dd> Initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_CUBE_MAP}} texture with |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/pixelWidth}} and {{XRLayerInit/pixelHeight}} values.
      <dt> Otherwise
        <dd> Initialize |array| with 2 new instance of {{WebGLTexture}} created as a {{TEXTURE_CUBE_MAP}} texture with |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/pixelWidth}} and {{XRLayerInit/pixelHeight}} values.
      </dt>
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

ISSUE: Define how cubemap sizes are determined.

ISSUE: Determine if depth textures are needed for cubemap layers.

ISSUE: determine the initial state of {{XRCubeLayer/orientation}}.

<div class="algorithm" data-algorithm="validate the state of the XRWebGLSubImage creation function">

To <dfn>validate the state of the XRWebGLSubImage creation function</dfn> of a {{XRWebGLBinding}} |binding| with parameters of {{XRCompositionLayer}} |layer| and {{XRFrame}} |frame|, the user agent MUST run the following steps:
  1. If |frame|'s {{XRFrame/session}} is not equal to |layer|'s [=XRCompositionLayer/session=], return <code>false</code> and abort these steps.
  1. If |frame|'s [=XRFrame/active=] boolean is <code>false</code>, return <code>false</code> and abort these steps.
  1. If |frame|'s [=XRFrame/animationFrame=] boolean is <code>false</code>, return <code>false</code> and abort these steps.
  1. If |binding|'s {{session}} is not equal to |layer|'s [=XRCompositionLayer/session=], return <code>false</code> and abort these steps.
  1. If |binding|'s {{context}} is not equal to |layer|'s [=XRCompositionLayer/context=], return <code>false</code> and abort these steps.
  1. If the |layer|'s [=colorTextures=] array is empty or missing, return <code>false</code> and abort these steps.
  1. return <code>true</code>

</div>

<div class="algorithm" data-algorithm="getSubImageAlgo">
The <dfn method for="XRWebGLBinding">getSubImage(XRCompositionLayer |layer|, XRFrame |frame|)</dfn> method creates a new {{XRWebGLSubImage}}.

When this method is invoked, it MUST run the following steps:

  1. Let |subimage| be a new {{XRWebGLSubImage}}
  1. If |layer|'s {{XRCompositionLayer/layout}} attribute is {{XRLayerLayout/"stereo"}}, throw an {{InvalidStateError}} and abort these steps.
  1. If [=validate the state of the XRWebGLSubImage creation function=] with |layer| and |frame| is <code>false</code>, throw an {{InvalidStateError}} and abort these steps.
  1. Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} with the first element of the |layer|'s [=colorTextures=] array.
  1. If the layer has a depthStencilTexture, initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with the first element of the |layer|'s [=depthStencilTextures=] array.
  1. return |subimage|

</div>

<div class="algorithm" data-algorithm="getViewSubImageAlgo">
The <dfn method for="XRWebGLBinding">getViewSubImage(XRCompositionLayer |layer|, XRView |view|)</dfn> method creates a new {{XRWebGLSubImage}}.

When this method is invoked, it MUST run the following steps:

  1. Let |subimage| be a new {{XRWebGLSubImage}}
  1. let |frame| be |view|'s {{frame}}.
  1. If [=validate the state of the XRWebGLSubImage creation function=] with |layer| and |frame| is <code>false</code>, throw an {{InvalidStateError}} and abort these steps.
  1. let |index| be a new integer with the value <code>0</code>.
  1. If |view|'s {{XRView/eye}} attribute is {{XREye/"right"}}, set |index| to <code>1</code>.
  1. Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} as follows:
    <dl class="switch">
      <dt class="switch">If the |layer| was created with a textureType of {{"texture-array"}}
      <dd> Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} with the first element of the |layer|'s [=colorTextures=] array.
      <dd> Initialize |subimage|'s {{XRWebGLSubImage/imageIndex}} with |index|.
      <dt> Otherwise
      <dd> Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} with the element at offset |index| of the |layer|'s [=colorTextures=] array.
    </dl>
  1. Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} as follows:
    <dl class="switch">
      <dt class="switch">If the |layer|'s [=depthStencilTextures=] is an empty array.
      <dd> Continue to the next entry.
      <dt> Else if the |layer| was created with a textureType of {{"texture-array"}}
      <dd> Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with the element at offset |index| of the |layer|'s [=depthStencilTextures=] array.
      <dt> Otherwise
      <dd> Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with the element of the |layer|'s [=depthStencilTextures=] array that corresponds to the |view|.
    </dl>
  1. return |subimage|

</div>

Video layer creation {#videolayer}
====================

ISSUE: this section needs to be enhanced.

XRMediaLayerInit {#xrmedialayerinittype}
----------------
The {{XRMediaLayerInit}} dictionary represents a set of configurable values that describe how a {{XRCompositionLayer}} containing a video
is initialized.

<pre class="idl">
dictionary XRMediaLayerInit {
  XRLayerLayout layout = "mono";
  boolean invertStereo = false;
};
</pre>

The <dfn dict-member for="XRMediaLayerInit">layout</dfn> attribute defines the layout of the video in the {{XRCompositionLayer}}.

The <dfn dict-member for="XRMediaLayerInit">invertStereo</dfn> attribute defines if natural location of each view in the video
should be inverted.

XRMediaBinding {#xrmediabindingtype}
-------------------
The {{XRMediaBinding}} object is used to create layers that display the content of an {{HTMLVideoElement}}.

NOTE: It is possible to create more than one {{XRMediaBinding}}. The lifetime of layers is not tied to the lifetime of
the {{XRMediaBinding}} that created them.

<pre class="idl">
interface XRMediaBinding {
  constructor(XRSession session);

  XRQuadLayer createQuadVideoLayer(HTMLVideoElement video,
                                   optional XRMediaLayerInit init = {});
  XRCylinderLayer createCylinderVideoLayer(HTMLVideoElement video,
                                           optional XRMediaLayerInit init = {});
  XREquirectLayer createEquirectVideoLayer(HTMLVideoElement video,
                                           optional XRMediaLayerInit init = {});
};

</pre>

WebXR Device API Integration {#webxrintegration}
============================

XRRenderState changes {#xrrenderstatechanges}
---------------------
This module extends the {{XRRenderStateInit}} and {{XRRenderState}} interfaces with a new optional array {{XRRenderStateInit/layers}} containing
instances of {{XRLayer}}.

<pre class="idl">
[SecureContext, Exposed=Window] partial interface XRRenderState {
  readonly attribute FrozenArray&lt;XRLayer&gt;? layers;
};
</pre>

The <dfn attribute for="XRRenderState">layers</dfn> attribute returns an array containing
the instances of {{XRLayer}} that are displayed by the [=XR Compositor=].

<div class="algorithm" data-algorithm="initialize-renderstate-for-layers">
This module replaces the steps given by [=initialize the render state=]. Instead when an {{XRRenderState}} object |state|
is created for an {{XRSession}} |session|, the user agent MUST <dfn dfn-for="layers">initialize the render state</dfn> by running the following steps:
  1. Initialize |state| by running the original steps to [=initialize the render state=].
  1. Initialize |state|'s {{XRRenderState/layers}} as follows:
    <dl class="switch">
      <dt class="switch">If the |session| was created with "[=feature descriptor/layers=]" enabled
      <dd> Initialize |state|'s {{XRRenderState/layers}} with a new empty array.
      <dt> Otherwise
      <dd> set |state|'s {{XRRenderState/layers}} to <code>null</code>.
    </dl>

</div>

updateRenderState changes {#updaterenderstatechanges}
-------------------------

<div class="algorithm" data-algorithm="update-layers-state-for-layers">

This module replaces the steps given by "[=update the pending layers state=]". Instead when the user agent will
<dfn dfn-for="layers">update the pending layers state</dfn> with {{XRSession}} |session| and {{XRRenderStateInit}} |newState|, it must run the following steps:
  1. If the |session| was not created with "[=feature descriptor/layers=]" enabled:
    1. If {{XRRenderStateInit/layers}} is not <code>null</code>, throw an {{NotSupportedError}}.
    1. Abort these steps.
  1. If |newState|'s {{XRRenderStateInit/baseLayer}} is set, throw a {{InvalidStateError}} and abort these steps.
  1. If |newState|'s {{XRRenderStateInit/layers}} contains duplicate instances, throw an {{InvalidStateError}} and abort these steps.
  1. For each |layer| in |newState|'s {{XRRenderStateInit/layers}}:
    1. If |layer| is a {{XRCompositionLayer}} and |layer|'s [=XRCompositionLayer/session=] is different from |session|, throw an {{InvalidStateError}} and abort these steps.
    1. If |layer| is a {{XRWebGLLayer}} and |layer|'s [=XRWebGLLayer/session=] is different from |session|, throw an {{InvalidStateError}} and abort these steps.
  1. Let |activeState| be |session|'s [=active render state=].
  1. If |session|'s [=pending render state=] is <code>null</code>, set it to a copy of |activeState|.
  1. If |newState|'s {{XRRenderStateInit/layers}} array is set, set |session|'s [=pending render state=]'s {{XRRenderState/layers}} to |newState|'s {{XRRenderStateInit/layers}}.

</div>


Security and Privacy Considerations {#security}
===============================================

Timing of the composition {#xrcompositiontiming}
-------------------------

Composition timing MUST be independent of the content that is rendered.
Moreover, content in a layer MUST not be observable in other layers.

If possible, composition of layers should happen outside the browser to reduce risk of timing attacks or other security vulnerabilities.
