<pre class="metadata">
Shortname: webxrlayers-1
Title: WebXR Layers API Level 1
Group: immersivewebwg
Status: w3c/ED
TR:
ED:
Previous Version:
Repository: immersive-web/layers
Level: 1
Mailing List Archives: https://lists.w3.org/Archives/Public/public-immersive-web/

Editor: Rik Cabanier, Facebook https://oculus.com, cabanier@fb.com

Abstract: This specification describes support for accessing the geometry of real world objects during a WebXR session.
</pre>

<pre class="link-defaults">
spec:infra;
    type: dfn; text:string
spec: permissions-request-1;
    type: dfn; text: request(permissionDesc); for: Permissions
spec: webxr-1;
    type: dfn; text: immersive xr device; for: XR
    type: dfn; text: xr device; for: /
    type: dfn; text: active; for: XRFrame
    type: dfn; text: eye; for: XRView
    type: dfn; text: initialize the render state
    type: dfn; text: active render state
    type: dfn; text: pending render state
    type: dfn; text: apply the pending render state
    type: dfn; text: viewer reference space
    type: dfn; text: xr animation frame
    type: dfn; text: feature descriptor
    type: dfn; text: feature requirement
    type: dfn; text: active immersive session
    type: dfn; text: type; for: XRReferenceSpace
    type: dfn; text: session; for: XRSpace
    type: dfn; text: XRLayer
    type: dfn; text: XRReferenceSpace
    type: dfn; text: type; for: XRReferenceSpace
    type: dfn; text: updateRenderState; for: XRSession
    type: dfn; text: session; for: XRWebGLLayer
    type: dfn; text: layers; for: XRRenderStateInit
spec: html;
    type: dfn; text: check the usability of the image argument
    type: dfn; text: request the xr permission
</pre>

<pre class="anchors">
spec: WebXR Device API - Level 1; urlPrefix: https://www.w3.org/TR/webxr/#
    type: dfn; text: feature descriptor
    type: dfn; text: xr compositor
    type: dfn; text: recommended WebGL framebuffer resolution
    type: dfn; text: native WebGL framebuffer resolution
    type: dfn; text: immersive session
    type: dfn; text: xr compatible
    type: dfn; text: ended
    type: dfn; text: context
    type: dfn; text: XRFrame/active
    type: dfn; text: XRView/active
    type: dfn; text: eye; for: XRView
    type: dfn; text: frame
    type: dfn; text: animationFrame; for: XRFrame
    type: dfn; text: XRSession/requestAnimationFrame()
spec: WebGL; urlPrefix: https://www.khronos.org/registry/webgl/specs/latest/1.0/
    type: interface; text: WebGLFramebuffer; url: WebGLFramebuffer
    type: interface; text: WebGLTexture; url: WebGLTexture
    type: interface; text: WebGLRenderingContext; url: WebGLRenderingContext
    type: interface; text: WebGLRenderingContextBase; url: WebGLRenderingContextBase
    type: interface; text: GLenum
    type: typedef; text: TEXTURE_2D; url: 5.14
    type: typedef; text: TEXTURE_CUBE_MAP; url: 5.14
spec: WebGL 2.0; urlPrefix: https://www.khronos.org/registry/webgl/specs/latest/2.0/
    type: interface; text: WebGL2RenderingContext; url: WebGL2RenderingContext
    type: typedef; text: TEXTURE_2D_ARRAY; url: 3.7
    type: dfn; text: texStorage2D; url: 3.7.6
    type: dfn; text: texStorage3D; url: 3.7.6
spec: WEBGL_depth_texture; urlPrefix: https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/
    type: typedef; text: WEBGL_depth_texture
</pre>

<pre class=link-defaults>
    spec:webxr-ar-module-1; type:enum-value; text:"immersive-ar"
</pre>

<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">

<style>
  .unstable::before {
    content: "This section is not stable";
    display: block;
    font-weight: bold;
    text-align: right;
    color: red;
  }
  .unstable {
    border: thin solid pink;
    border-radius: .5em;
    padding: .5em;
    margin: .5em calc(-0.5em - 1px);
    background-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='300' height='290'><text transform='rotate(-45)' text-anchor='middle' font-family='sans-serif' font-weight='bold' font-size='70' y='210' opacity='.1'>Unstable</text></svg>");
    background-repeat: repeat;
    background-color: #FFF4F4;
  }
  .unstable h3:first-of-type {
    margin-top: 0.5rem;
  }

  .unstable.example:not(.no-marker)::before {
    content: "Example " counter(example) " (Unstable)";
    float: none;
  }

  .non-normative::before {
    content: "This section is non-normative.";
    font-style: italic;
  }
  .tg {
    border-collapse: collapse;
    border-spacing: 0;
  }
  .tg th {
    border-style: solid;
    border-width: 1px;
    background: #90b8de;
    color: #fff;
    font-family: sans-serif;
    font-weight: bold;
    border-color: grey;
  }
  .tg td {
    padding: 4px 5px;
    background-color: rgb(221, 238, 255);
    font-family: monospace;
    border-style: solid;
    border-width: 1px;
    border-color: grey;
    overflow: hidden;
    word-break: normal;
  }
</style>

Introduction {#intro}
============

<section class="non-normative">

The spec adds support of `composition` layers to the WebXR spec. The benefits of layers are as follows:

 * <b>Performance and judder</b> Composition layers are presented at the frame rate of the compositor (i.e. native refresh rate of HMD) rather than at the application frame rate.
    Even when the application is not updating the layer's rendering at the native refresh rate of the compositor, the compositor might be able to re-project the existing
    rendering to the proper pose. This results in smoother rendering and less judder. Another feature of layers is that each of them can have different resolution. This allows the
    application to scale down the main eye buffer resolution on low performance systems, but keeping essential information, such as text or a map, in its own layer at a higher
    resolution.

 * <b>Legibility/visual fidelity</b> The resolution for eye-buffers for 3D world rendering can be set to relatively low values especially on low performance systems. It would
    be impossible to render high fidelity content, such as text, in this case. Each layer may have its own resolution and it will be re-sampled only once by the compositor (in contrary
    to the traditional approach with rendering layers via WebGL where the layer's content got re-sampled at least twice: once when rendering into WebGL
    eye-buffer (and losing a lot of details due to limited eye-buffer resolution) and the second time by the compositor).

 * <b>Power consumption / battery life</b> Due to reduced rendering pipeline, the lack of double sampling and no need to update the layer's rendering each frame, the power
    consumption is expected to be improved.

 * <b>Latency</b> Pose sampling for composition layers may occur at the very end of the frame and then certain reprojection techniques could be used to update the layer's pose to
    match it with the most recent HMD pose. This may significantly reduce the effective latency for the layers' rendering and as a result improve overall experience.

ISSUE: how to do hit testing? Should it be done by the UA?

</section>


Terminology {#terminology}
-----------

Application flow {#applicationflow}
----------------

<section class="non-normative">

If an author wants to use layers, they have to go through these steps:
 1. request support through {{XRPermissionDescriptor/requiredFeatures}} or {{XRPermissionDescriptor/optionalFeatures}} in {{XRSystem/requestSession()}}
 1. create a {{XRWebGLBinding}} or {{XRMediaBinding}}
 1. create layers with these objects
 1. add the layers to {{XRRenderStateInit}} and call {{XRSession/updateRenderState()}}
 1. during {{XRSession/requestAnimationFrame()}} for webgl layers, draw content each gl layer

</section>

Initialization {#initialization}
==============

In order for the applications to signal their interest in using layers during a session,
the session MUST be requested with an appropriate [=feature descriptor=]. The string "<dfn for="feature descriptor">layers</dfn>" is introduced
by this module as a new valid [=feature descriptor=] for the WebXR Layers feature.

<div class="example">
The following code requests layers as an optional feature.

<pre highlight="js">
navigator.xr.requestSession('immersive-vr', {
    optionalFeatures: ['layers']
  }
</pre>
</div>

Layers are only supported for XRSessions created with XRSessionMode of {{XRSessionMode/"immersive-vr"}}
or {{XRSessionMode/"immersive-ar"}}. {{XRSessionMode/"inline"}} sessions MUST not support layers.

The "[=feature descriptor/layers=]" [=feature descriptor=] has a [=feature requirement=] that it cannot be enabled when there is an [=active immersive session=].

NOTE: This means that executing the {{Permissions/request(permissionDesc)}} API with "[=feature descriptor/layers=]" will
not enable layers support for the current active session.

Layer types {#xrlayertypes}
===========

Mono and stereo layers {#monovsstereo}
----------------------
A stereo layer MUST supply a different {{XRSubImage}} to render to for each view.

A mono layer MUST supply a single {{XRSubImage}} which is shown to each view.

The [=XR Compositor=] MUST ensure that layers are presented correctly in stereo to the observer.

XRLayerLayout {#xrlayerlayouttype}
-------------
The {{XRLayerLayout}} enum defines the layout of the layer.

<pre class="idl">
enum XRLayerLayout {
  "mono",
  "stereo",
  "stereo-left-right",
  "stereo-top-bottom"
};
</pre>

 - A layout of <dfn enum-value for="XRLayerLayout">mono</dfn> indicates that the layer is mono.
 - A layout of <dfn enum-value for="XRLayerLayout">stereo</dfn> indicates that the layer is in stereo. It's left to the user agent what layout to use.
 - A layout of <dfn enum-value for="XRLayerLayout">stereo-left-right</dfn> indicates that the layer is in stereo and divided left to right.
 - A layout of <dfn enum-value for="XRLayerLayout">stereo-top-bottom</dfn> indicates that the layer is in stereo and divided top to bottom.

 NOTE: If an {{XRCompositionLayer}} is created with an {{XRLayerLayout/"stereo"}} layout, it is highly recommended that it is allocated with an {{XRTextureType/"texture-array"}} texture type.

XRCompositionLayer {#xrcompositionlayertype}
--------------
XRCompositionLayer defines a set of common attributes and behaviors across certain layer types.

<pre class="idl">
interface XRCompositionLayer : XRLayer {
  readonly attribute XRLayerLayout layout;
  readonly attribute unsigned long viewPixelWidth;
  readonly attribute unsigned long viewPixelHeight;

  attribute boolean blendTextureSourceAlpha;
  attribute boolean chromaticAberrationCorrection;
  readonly attribute boolean needsRedraw;

  void destroy();
};
</pre>

The <dfn attribute for="XRCompositionLayer">layout</dfn> attribute returns the layout of the layer.

The <dfn attribute for="XRCompositionLayer">viewPixelWidth</dfn> and <dfn attribute for="XRCompositionLayer">viewPixelHeight</dfn> attributes
return the width and height of the GL attachments, respectively. If there are no attachments, they will return 0.

The <dfn attribute for="XRCompositionLayer">blendTextureSourceAlpha</dfn> attribute enables the layer’s texture alpha channel.

The <dfn attribute for="XRCompositionLayer">chromaticAberrationCorrection</dfn> attribute is a hint for the [=XR Compositor=] to
enable optical chromatic aberration correction for the layer. Only valid if this isn't done by default.

ISSUE: describe what chromaticAberrationCorrection does.

The <dfn attribute for="XRCompositionLayer">needsRedraw</dfn> attribute signals that the {{XRCompositionLayer}} should be
rerendered in the next [=XR animation frame=]. It MAY be set when [=the underlying resources of a layer are lost=] or
when the [=XR Compositor=] can no longer reproject the layer. Failing to redraw the content in the next [=XR animation frame=]
might cause flickering or other side effects.

<div class="algorithm" data-algorithm="redrawLayerAlgo">
When <dfn>the underlying resources of a layer are lost</dfn> for an {{XRCompositionLayer}} |layer|,
the user agent MUST run the following steps:
  1. Set the |layer|'s {{XRCompositionLayer/needsRedraw}} array to an empty array.
  1. If |layer| is not a {{XRProjectionLayer}}, [=queue a task=] to [=fire an event=] named {{redraw}} on |layer|.

</div>

{{destroy()}} will delete the underlying attachments. If there are no attachments, this function does nothing.

<div class="algorithm" data-algorithm="calling destroy on a layer">

When calling {{destroy()}} on {{XRCompositionLayer}} |layer|, the user agent MUST run the following steps:
  1. Set the |layer|'s [=colorTextures=] array to an empty array.
  1. Set the |layer|'s [=depthStencilTextures=] array to an empty array.
  1. Destroy the underlying GL attachments.

</div>

Each {{XRCompositionLayer}} has a <dfn for="XRCompositionLayer">context</dfn> object which is an instance
of either null or a {{WebGLRenderingContext}} or a {{WebGL2RenderingContext}} and a <dfn for="XRCompositionLayer">media</dfn>
object which is an instance of null or a {{HTMLVideoElement}}.

Each {{XRCompositionLayer}} has an associated <dfn for="XRCompositionLayer">session</dfn>, which is the
{{XRSession}} it was created with.

<div class="algorithm" data-algorithm="setting the space on a layer">

When <dfn>setting the space on a layer</dfn> with {{XRSpace}} |space| and {{XRCompositionLayer}} |layer|, the user agent MUST run the following steps to validate if the |space| is valid:
  1. If |space| is <code>null</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |space|'s [=XRSpace/session=] is not equal to the |layer|'s [=XRCompositionLayer/session=], throw {{InvalidStateError}} and abort these steps.

</div>

XRProjectionLayer {#xrprojectionlayertype}
-----------------
An {{XRProjectionLayer}} is a layer that fills the entire view of the observer.
Projection layers should be refreshed close to the device's native frame rate.

<pre class="idl">
interface XRProjectionLayer : XRCompositionLayer {
  readonly attribute boolean ignoreDepthValues;
};
</pre>

The <dfn attribute for="XRProjectionLayer">ignoreDepthValues</dfn> attribute, if <code>true</code>, indicates that the
[=XR Compositor=] MUST NOT make use of values in the depth buffer attachment when rendering. When the attribute
is <code>false</code> it indicates that the content of the depth buffer attachment will be used by the
[=XR Compositor=] and is expected to be representative of the scene rendered into the layer.

XRQuadLayer {#xrquadlayertype}
-----------
An {{XRQuadLayer}} renders a layer that takes up a flat rectangular space in the virtual environment.
Only the front of the layer MUST be visible; the back face MUST not be drawn by the [=XR Compositor=].

A XRQuadLayer has no thicknes. It is a two-dimensional object positioned and oriented in 3D space. The position
of a quad refers to the center of the quad.

<pre class="idl">
interface XRQuadLayer : XRCompositionLayer {
  attribute XRSpace space;
  attribute XRRigidTransform transform;

  attribute float width;
  attribute float height;

  // Events
  attribute EventHandler onredraw;
};
</pre>

The <dfn attribute for="XRQuadLayer">transform</dfn> attributes sets and returns the offset and orientation relative to the
<dfn attribute for="XRQuadLayer">space</dfn> attribute. The {{XRQuadLayer/transform}} and {{XRQuadLayer/space}} attributes
establish the spatial relationship of the layer within the user’s physical environment.
When setting the {{XRQuadLayer/space}}, first run the steps for [=setting the space on a layer=].

The <dfn attribute for="XRQuadLayer">width</dfn> and <dfn attribute for="XRQuadLayer">height</dfn> attributes
set and return the width and height of the layer in meters.

<div class="algorithm" data-algorithm="initQuadLayerAlgo">
When <dfn lt="initialize a quad layer">initializing a {{XRQuadLayer}} |layer| with a {{XRQuadLayerInit}} |init|</dfn>, the user agent MUST run the following steps:
  1. Initialize |layer|'s {{XRQuadLayer/width}} to |init|'s {{XRQuadLayerInit/width}}.
  1. Initialize |layer|'s {{XRQuadLayer/height}} to |init|'s {{XRQuadLayerInit/height}}.
  1. Let |layer|'s {{XRQuadLayer/space}} be the |init|'s {{XRLayerInit/space}}.
  1. Initialize |layer|'s {{XRQuadLayer/transform}} as follows:
    <dl class="switch">
      <dt class="switch">If |init|'s {{XRQuadLayerInit/transform}} is set
      <dd> Let |layer|'s {{XRQuadLayer/transform}} be a new {{XRRigidTransform}} initialized with {{XRRigidTransform/position}} and {{XRRigidTransform/orientation}} of |init|'s {{XRQuadLayerInit/transform}}.
      <dt> Otherwise
      <dd> Let |layer|'s {{XRQuadLayer/transform}} be a new {{XRRigidTransform}} initialized with a {{DOMPointInit}} position of <code>{ x: 1.0, y: 0.0, z: 0.0, w: 1.0 }</code>.
    </dl>

</div>

The <dfn attribute for="XRQuadLayer">onredraw</dfn> attribute is an Event handler IDL attribute for the {{redraw}} event type.

XRCylinderLayer {#xrcylinderayertype}
---------------
An {{XRCylinderLayer}} renders a layer that takes up a curved rectangular space in the virtual environment.
Only the front of the layer MUST be visible; the back face MUST not be drawn by the [=XR Compositor=].

A XRCylinderLayer has no thicknes. It is a two-dimensional object positioned and oriented in 3D space. The position
of the cylinder refers to the center of the quad.

<pre class="idl">
interface XRCylinderLayer : XRCompositionLayer {
  attribute XRSpace space;
  attribute XRRigidTransform transform;

  attribute float radius;
  attribute float centralAngle;
  attribute float aspectRatio;

  // Events
  attribute EventHandler onredraw;
};
</pre>

The <dfn attribute for="XRCylinderLayer">transform</dfn> attribute sets and returns the offset and orientation relative to the
<dfn attribute for="XRCylinderLayer">space</dfn> attribute. The {{XRCylinderLayer/transform}} and {{XRCylinderLayer/space}} attributes
establish the spatial relationship of the layer within the user’s physical environment.
When setting the {{XRCylinderLayer/space}}, first run the steps for [=setting the space on a layer=].

The <dfn attribute for="XRCylinderLayer">radius</dfn> attribute controls the radius in meters of the cylinder.

The <dfn attribute for="XRCylinderLayer">centralAngle</dfn> attribute controls the angle in radians of the visible section of the cylinder.
It grows symmetrically around the 0 angle.

The <dfn attribute for="XRCylinderLayer">aspectRatio</dfn> attribute controls the ratio of the visible cylinder section.

<img src="images/cylinder_layer_params.png" style="width:80%"/>

<div class="algorithm" data-algorithm="initCylinderLayerAlgo">
When <dfn lt="initialize a cylinder layer">initializing a {{XRCylinderLayer}} |layer| with a {{XRCylinderLayerInit}} |init|</dfn>, the user agent MUST run the following steps:
  1. Initialize |layer|'s {{XRCylinderLayer/radius}} to |init|'s {{XRCylinderLayerInit/radius}}.
  1. Initialize |layer|'s {{XRCylinderLayer/centralAngle}} to |init|'s {{XRCylinderLayerInit/centralAngle}}.
  1. Initialize |layer|'s {{XRCylinderLayer/aspectRatio}} to |init|'s {{XRCylinderLayerInit/aspectRatio}}.
  1. Let |layer|'s {{XRCylinderLayer/space}} be the |init|'s {{XRLayerInit/space}}.
  1. Initialize |layer|'s {{XRCylinderLayer/transform}} as follows:
    <dl class="switch">
      <dt class="switch">If |init|'s {{XRCylinderLayerInit/transform}} is set
      <dd> Let |layer|'s {{XRCylinderLayer/transform}} be a new {{XRRigidTransform}} initialized with {{XRRigidTransform/position}} and {{XRRigidTransform/orientation}} of |init|'s {{XRCylinderLayerInit/transform}}.
      <dt> Otherwise
      <dd> Let |layer|'s {{XRCylinderLayer/transform}} be a new {{XRRigidTransform}} initialized with a {{DOMPointInit}} position of <code>{ x: 1.0, y: 0.0, z: 0.0, w: 1.0 }</code>.
    </dl>

</div>

The <dfn attribute for="XRCylinderLayer">onredraw</dfn> attribute is an Event handler IDL attribute for the {{redraw}} event type.

XREquirectLayer {#xrequirectlayertype}
---------------
An {{XREquirectLayer}} renders a layer where the [=XR Compositor=] MUST map an equirectangular coded data onto the inside of a sphere.

ISSUE: this section needs clarification

<pre class="idl">
interface XREquirectLayer : XRCompositionLayer {
  attribute XRSpace space;
  attribute XRRigidTransform transform;

  attribute float radius;
  attribute float scaleX;
  attribute float scaleY;
  attribute float biasX ;
  attribute float biasY;

  // Events
  attribute EventHandler onredraw;
};
</pre>

The <dfn attribute for="XREquirectLayer">transform</dfn> attribute sets and returns the offset and orientation relative to
{{XREquirectLayer/space}}. The {{XREquirectLayer/transform}} attribute and the {{XREquirectLayer/space}}
establish the spatial relationship of the layer within the user’s physical environment.

The <dfn attribute for="XREquirectLayer">radius</dfn> attribute is the non-negative radius of the sphere. Values of less than or
equal to zero or infinity are treated as an infinite sphere.

The <dfn attribute for="XREquirectLayer">scaleX</dfn> and <dfn attribute for="XREquirectLayer">scaleY</dfn> attributes
set and return a scale of the texture coordinates after the mapping to 2D.

The <dfn attribute for="XREquirectLayer">biasX</dfn> and <dfn attribute for="XREquirectLayer">biasY</dfn> attributes
set and return a bias of the texture coordinates after the mapping to 2D.

When assigning an {{XRSpace}} to the {{XREquirectLayer/space}} attribute, first run the following steps.

<div class="algorithm" data-algorithm="setting the space on an equirect layer">

When <var ignore>setting the space on an equirect layer</var> with {{XRSpace}} |space| and {{XREquirectLayer}} |layer|, the user agent MUST run the following steps to validate if the |space| is valid:
  1. If |init|'s {{XRLayerInit/space}} is not an instance of type {{XRReferenceSpace}}, throw {{InvalidStateError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} has a [=XRReferenceSpace/type=] of {{XRReferenceSpaceType/"viewer"}}, throw {{InvalidStateError}} and abort these steps.
  1. Run [=setting the space on a layer=] with |space| and |layer|.

</div>

<div class="algorithm" data-algorithm="initEquirectLayerAlgo">
When <dfn lt="initialize a equirect layer">initializing a {{XREquirectLayer}} |layer| with a {{XREquirectLayerInit}} |init|</dfn>, the user agent MUST run the following steps:
  1. Initialize |layer|'s {{XREquirectLayer/radius}} to |init|'s {{XREquirectLayerInit/radius}}.
  1. Initialize |layer|'s {{XREquirectLayer/scaleX}} to |init|'s {{XREquirectLayerInit/scaleX}}.
  1. Initialize |layer|'s {{XREquirectLayer/scaleY}} to |init|'s {{XREquirectLayerInit/scaleY}}.
  1. Initialize |layer|'s {{XREquirectLayer/biasX}} to |init|'s {{XREquirectLayerInit/biasX}}.
  1. Initialize |layer|'s {{XREquirectLayer/biasY}} to |init|'s {{XREquirectLayerInit/biasY}}.
  1. Let |layer|'s {{XREquirectLayer/space}} be the |init|'s {{XRLayerInit/space}}.
  1. Initialize |layer|'s {{XREquirectLayer/transform}} as follows:
    <dl class="switch">
      <dt class="switch">If |init|'s {{XREquirectLayerInit/transform}} is set
      <dd> Let |layer|'s {{XREquirectLayer/transform}} be a new {{XRRigidTransform}} initialized with {{XRRigidTransform/position}} and {{XRRigidTransform/orientation}} of |init|'s {{XREquirectLayerInit/transform}}.
      <dt> Otherwise
      <dd> Let |layer|'s {{XREquirectLayer/transform}} be a new {{XRRigidTransform}}.
    </dl>

</div>

The <dfn attribute for="XREquirectLayer">onredraw</dfn> attribute is an Event handler IDL attribute for the {{redraw}} event type.

XRCubeLayer {#xcubelayertype}
-----------
A {{XRCubeLayer}} renders a layer where the [=XR Compositor=] renders directly from a cubemap.

ISSUE: this section needs clarification

<pre class="idl">
interface XRCubeLayer : XRCompositionLayer {
  attribute XRSpace space;
  attribute DOMPointReadOnly orientation;

  // Events
  attribute EventHandler onredraw;
};
</pre>

The <dfn attribute for="XRCubeLayer">orientation</dfn> attribute sets and returns the orientation relative to the
<dfn attribute for="XRCubeLayer">space</dfn> attribute. The {{XRCubeLayer/orientation}} and {{XRCubeLayer/space}} attributes
establish the spatial relationship of the layer within the user’s physical environment.
When placing the {{XRCubeLayer}} only the orientation of the {{XRCubeLayer/space}} is considered. The cube layer will always be rendered
with the view point at the center.

When assigning an {{XRSpace}} to the {{XRCubeLayer/space}} attribute, first run the following steps.

<div class="algorithm" data-algorithm="setting the space on a cube layer">

When <var ignore>setting the space on an cube layer</var> with {{XRSpace}} |space| and {{XRCubeLayer}} |layer|, the user agent MUST run the following steps to validate if the |space| is valid:
  1. If |init|'s {{XRLayerInit/space}} is not an instance of type {{XRReferenceSpace}}, throw {{InvalidStateError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} has a [=XRReferenceSpace/type=] of {{XRReferenceSpaceType/"viewer"}}, throw {{InvalidStateError}} and abort these steps.
  1. Run [=setting the space on a layer=] with |space| and |layer|.

</div>

The <dfn attribute for="XRCubeLayer">onredraw</dfn> attribute is an Event handler IDL attribute for the {{redraw}} event type.

Spaces {#spaces}
======

{{XRProjectionLayer}} and {{XRWebGLLayer}} don't have associated an {{XRSpace}} because they render to the full frame.

{{XRCubeLayer}} and {{XREquirectLayer}} MUST only support {{XRReferenceSpace|XRReferenceSpaces}} that are not of type {{"viewer"}}.

{{XRQuadLayer}} and {{XRCylinderLayer}} MUST support all {{XRSpace}} types.

<section class="non-normative">

Generally, developers should not use of {{"viewer"}} space to stabilize layers, as this will almost always defeat positional or
rotational reprojection and result in a loss in stability of the rendered content relative to the world. The exception being small UI elements
like a gaze cursor or targeting reticle.

Following are some best practices of spaces to use with a layer type:
  - {{XRQuadLayer}} with {{"viewer"}} space: Head-locked constant-size reticle in center of screen.
  - {{XRQuadLayer}} or {{XRCylinderLayer}} in {{"local"}}, {{"unbounded"}} space: springy body-locked UI.
  - {{XRQuadLayer}} or {{XRCylinderLayer}} in {{"local"}}, {{"local-floor"}}, {{"unbounded"}}, {{"bounded-floor"}} or anchor space: world-locked video, placed by the user.
  - {{XREquirectLayer}} or {{XRCubeLayer}} in {{"local"}} space: 360-degree video or skybox.

</section>

Rendering {#rendering}
=========

XRSubImage {#xrsubimagetype}
----------
The {{XRSubImage}} object represents what viewport of the GPU texture to use.

<pre class="idl">
interface XRSubImage {
  [SameObject] readonly attribute XRViewport viewport;
};
</pre>

NOTE: this class is designed to accomodate future extensions

The <dfn attribute for="XRSubImage">viewport</dfn> attribute returns the {{XRViewport}} to use when rendering the sub image.

XRWebGLSubImage {#xrwebglsubimagetype}
---------------
The {{XRWebGLSubImage}} object is used during rendering of the layer.

<pre class="idl">
interface XRWebGLSubImage : XRSubImage {
  [SameObject] readonly attribute WebGLTexture colorTexture;
  [SameObject] readonly attribute WebGLTexture? depthStencilTexture;
  readonly attribute unsigned long? imageIndex;
};
</pre>

The <dfn attribute for="XRWebGLSubImage">colorTexture</dfn> attribute returns the color {{WebGLTexture}} for the {{XRCompositionLayer}}.

The <dfn attribute for="XRWebGLSubImage">depthStencilTexture</dfn> attribute returns the depth/stencil {{WebGLTexture}} for the {{XRCompositionLayer}}.
If the layer was created without depth/stencil, this attribute returns null.

The <dfn attribute for="XRWebGLSubImage">imageIndex</dfn> attribute returns the offset into the texture array. Valid only for layers
that were requested with {{texture-array}}.

The {{XRWebGLSubImage/colorTexture}} and {{XRWebGLSubImage/depthStencilTexture}} objects MUST only be used during the [=XR animation frame=] of the
current session and MUST be made invalid once the [=XR animation frame=] completes.

In addition, they MUST behave as though they were allocated with [=texStorage2D=] or [=texStorage3D=], as appropriate,
even when using a WebGL 1.0 context.

NOTE: Changes to the dimensions or format of the {{XRWebGLSubImage/colorTexture}} or {{XRWebGLSubImage/depthStencilTexture}} objects are not allowed. GL commands
may only alter the texel values and texture parameters. Using any of the following
commands with the WebGLTexture will result in an INVALID_OPERATION error
being generated, even if it does not affect the dimensions or format: TexImage*, CompressedTexImage*, CopyTexImage* and TexStorage*.
The <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.0/es_spec_3.0.pdf#nameddest=section-3.8.4">"Immutable-Format Texture Images"</a>
section in the OpenGL ES 3.0 spec defines these limitations in more detail.


XRTextureType {#xrtexturetype}
-------------
The {{XRTextureType}} enum defines what type of texture is allocated.

<pre class="idl">
enum XRTextureType {
  "texture",
  "texture-array"
};
</pre>

- A texture type of <dfn enum-value for="XRTextureType">texture</dfn> indicates that the textures of {{XRWebGLSubImage}} must be of type {{TEXTURE_2D}}
- A texture type of <dfn enum-value for="XRTextureType">texture-array</dfn> indicates that the textures of {{XRWebGLSubImage}} must be of type {{TEXTURE_2D_ARRAY}}

GPU layer and view creation {#gpulayer}
===========================

Overview {#xrgpulayeroverview}
--------
<section class="non-normative">

When a layer is created it is backed by a GPU resource, typically a texture, provided by one of the Web platform's graphics APIs. In order to
specify which API is providing the layer's GPU resources a {{XRWebGLBinding}} for the API in question must be created.
Each graphics API may have unique requirements that must be satisfied before a context can be used in the creation of a layer. For example,
a {{WebGLRenderingContext}} must have its xrCompatible flag set prior to being passed to the constructor of the {{XRWebGLBinding}} instance.

Any interaction between the {{XRSession}} the graphics API, such as allocating or retrieving textures, will go through this {{XRWebGLBinding}} instance, and the exact mechanics
of the interaction will typically be API specific. This allows the rest of the WebXR API to be
graphics API agnostic and more easily adapt to future advances in rendering techniques.

Once a {{XRWebGLBinding}} instance has been acquired, it can be used to create a variety of {{XRCompositionLayer}}. Any layers created by that instance will then be able
to query the associated GPU resources each frame, generally expected to be the native API's texture interface.

The various layer types are created with the create____Layer series of methods on the {{XRWebGLBinding}} instance. Information about the graphics resources required,
such as whether or not to allocate a depth buffer or alpha channel, are passed in at layer creation time and will be immutable for the lifetime of the layer.
The method will return the associated XRCompositionLayer type.

Some layer types may not be supported by the {{XRSession}}. If a layer type isn't supported the method will throw an exception. {{XRProjectionLayer}} MUST be supported by all {{XRSession}}s.
</section>

XRProjectionLayerInit {#xrprojectionlayerinittype}
---------------------
The {{XRProjectionLayerInit}} dictionary represents a set of configurable values that describe how a {{XRProjectionLayer}}
is initialized.

<pre class="idl">
dictionary XRProjectionLayerInit {
  boolean depth = true;
  boolean stencil = false;
  boolean alpha = true;
  double scaleFactor = 1.0;
};
</pre>

The <dfn dict-member for="XRProjectionLayerInit">depth</dfn> attribute defines if the {{XRProjectionLayer}} will have a depth buffer.

The <dfn dict-member for="XRProjectionLayerInit">stencil</dfn> attribute defines if the {{XRProjectionLayer}} will have a stencil buffer.

The <dfn dict-member for="XRProjectionLayerInit">alpha</dfn> attribute defines if the {{XRProjectionLayer}} will have an alpha channel.

The <dfn dict-member for="XRProjectionLayerInit">scaleFactor</dfn> attribute defines the value that the |session|'s
[=recommended WebGL framebuffer resolution=] must be multiplied by determining the resolution of the layer's attachments.

XRLayerInit {#xrlayerinittype}
---------------------
The {{XRLayerInit}} dictionary represents a set of common configurable values for {{XRQuadLayer}}, {{XRCylinderLayer}},
{{XREquirectLayer}} and {{XRCubeLayer}} .

<pre class="idl">
dictionary XRLayerInit {
  required XRSpace space;
  required unsigned long viewPixelWidth;
  required unsigned long viewPixelHeight;
  XRLayerLayout layout = "mono";
  boolean depth = false;
  boolean stencil = false;
  boolean alpha = true;
};
</pre>

The <dfn dict-member for="XRLayerInit">space</dfn> attribute defines the spatial relationship with the user’s physical environment.

The <dfn dict-member for="XRLayerInit">viewPixelWidth</dfn> and <dfn dict-member for="XRLayerInit">viewPixelHeight</dfn> attributes define
the rectangular dimensions of the {{XRCompositionLayer}}.

The <dfn dict-member for="XRLayerInit">layout</dfn> attribute defines the layout of the layer.

The <dfn dict-member for="XRLayerInit">depth</dfn> attribute defines if the {{XRCompositionLayer}} view will have a depth buffer.

The <dfn dict-member for="XRLayerInit">stencil</dfn> attribute defines if the {{XRCompositionLayer}} view will have a stencil buffer.

The <dfn dict-member for="XRLayerInit">alpha</dfn> attribute defines if the {{XRCompositionLayer}} view will have an alpha channel.

XRQuadLayerInit {#xrquadlayerinit}
-------------------

The {{XRQuadLayerInit}} dictionary represents a set of configurable values that describe how a {{XRQuadLayer}} is initialized.

<pre class="idl">
dictionary XRQuadLayerInit : XRLayerInit {
  XRRigidTransform? transform;
  float width = 1.0;
  float height = 1.0;
};
</pre>

XRCylinderLayerInit {#xrcylinderlayerinit}
-------------------

The {{XRCylinderLayerInit}} dictionary represents a set of configurable values that describe how a {{XRCylinderLayer}} is initialized.

<pre class="idl">
dictionary XRCylinderLayerInit : XRLayerInit {
  XRRigidTransform? transform;
  float radius = 2.0;
  float centralAngle = 0.78539;
  float aspectRatio = 2.0;
};
</pre>

XREquirectLayerInit {#xrequirectlayerinit}
-------------------

The {{XREquirectLayerInit}} dictionary represents a set of configurable values that describe how a {{XREquirectLayer}} is initialized.

<pre class="idl">
dictionary XREquirectLayerInit : XRLayerInit {
  XRRigidTransform? transform;
  float radius = 10.0;
  float scaleX = 1.0;
  float scaleY = 1.0;
  float biasX = 0;
  float biasY = 0;
};
</pre>

XRCubeLayerInit {#xrcubelayerinit}
-------------------

The {{XRCubeLayerInit}} dictionary represents a set of configurable values that describe how a {{XRCubeLayer}} is initialized.

<pre class="idl">
dictionary XRCubeLayerInit : XRLayerInit {
  DOMPointReadOnly? orientation;
};
</pre>

XRWebGLBinding {#XRWebGLBindingtype}
-------------------
The {{XRWebGLBinding}} object is used to create layers that have a GPU backend.

<pre class="idl">
interface XRWebGLBinding {
  constructor(XRSession session, XRWebGLRenderingContext context);

  readonly attribute double nativeProjectionScaleFactor;

  XRProjectionLayer createProjectionLayer(XRTextureType textureType,
                                          optional XRProjectionLayerInit init);
  XRQuadLayer createQuadLayer(XRTextureType textureType,
                              optional XRQuadLayerInit init);
  XRCylinderLayer createCylinderLayer(XRTextureType textureType,
                                      optional XRCylinderLayerInit init);
  XREquirectLayer createEquirectLayer(XRTextureType textureType,
                                      optional XREquirectLayerInit init);
  XRCubeLayer createCubeLayer(optional XRCubeLayerInit init);

  XRWebGLSubImage getSubImage(XRCompositionLayer layer, XRFrame frame);
  XRWebGLSubImage getViewSubImage(XRCompositionLayer layer, XRView view);
};
</pre>

ISSUE: the init dictionaries shouldn't be optional. This is bikeshed issue 1566.

Each {{XRWebGLBinding}} has a <dfn dfn-for="XRWebGLBinding">context</dfn> object of type {{XRWebGLRenderingContext}} which is an instance
of either a {{WebGLRenderingContext}} or a {{WebGL2RenderingContext}}.

Each {{XRWebGLBinding}} has an associated <dfn dfn-for="XRWebGLBinding">session</dfn>, which is the
{{XRSession}} it was created with.

NOTE: It is possible to create more than one {{XRWebGLBinding}}. Any layer created with an instance of {{XRWebGLBinding}} can
be used with another instance of {{XRWebGLBinding}} as long as both were created with the same [=XRWebGLBinding/session=] and the same
[=XRWebGLBinding/context=]. The lifetime of layers or instances of {{XRWebGLSubImage}} is not tied to the lifetime of the {{XRWebGLBinding}} that created them.

Each {{XRCompositionLayer}} created through {{XRWebGLBinding}} has an internal <dfn>colorTextures</dfn> array which is an |array| of {{WebGLTexture}} for color textures and
an internal <dfn>depthStencilTextures</dfn> which is an |array| of {{WebGLTexture}}</dfn> for depth/stencil textures.

<div class="algorithm" data-algorithm="construct-webgl-layer">

The <dfn constructor for="XRWebGLBinding">XRWebGLBinding(|session|, |context|)</dfn> constructor
MUST perform the following steps when invoked:

  1. Let |binding| be a new {{XRWebGLBinding}}
  1. If |session|'s [=ended=] value is <code>true</code>, throw an {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw an {{InvalidStateError}} and abort these steps.
  1. If |session| is not an [=immersive session=], throw an {{InvalidStateError}} and abort these steps.
  1. If |context|'s [=XR compatible=] boolean is <code>false</code>, throw an {{InvalidStateError}} and abort these steps.
  1. Initialize |binding|'s [=XRWebGLBinding/context=] to |context|.
  1. Initialize |binding|'s [=XRWebGLBinding/session=] to |session|.
  1. Return |binding|.

</div>

The {{nativeProjectionScaleFactor}} function returns the value that the |session|'s [=recommended WebGL framebuffer resolution=]
MUST be multiplied by to yield the |session|'s [=native WebGL framebuffer resolution=].

<div class="algorithm" data-algorithm="determine the layout attribute">

To <dfn>determine the layout attribute</dfn> using a {{XRTextureType}} |textureType|, a {{XRWebGLRenderingContext}} |context| and a {{XRLayerInit}} |init|, the user agent MUST run the following steps:
  1. If |context| is not a {{WebGL2RenderingContext}} and |textureType| is {{"texture-array"}}, throw {{InvalidStateError}} and abort these steps.
  1. let |layout| be |init|'s {{XRLayerInit/layout}}.
  1. If |layout| is {{XRLayerLayout/"mono"}}, return |layout| and abort these steps.
  1. If |layout| is {{XRLayerLayout/"stereo"}}, run the following steps:
    1. If |textureType| is {{"texture-array"}}, return |layout| and abort these steps.
    1. If the user agent prefers {{XRLayerLayout/"stereo-left-right"}} layout, return {{XRLayerLayout/"stereo-left-right"}} and abort these steps.
    1. If the user agent prefers {{XRLayerLayout/"stereo-top-bottom"}} layout, return {{XRLayerLayout/"stereo-top-bottom"}} and abort these steps.
  1. If |textureType| is {{"texture-array"}}, throw {{InvalidStateError}} and abort these steps.
  1. return |layout|.

</div>

ISSUE: special case UA behavior if the size causes the layout to change (ie if the requested width exceeds a limit with {{XRLayerLayout/"stereo-left-right"}})

<div class="algorithm" data-algorithm="allocate color textures">

To <dfn>allocate color textures</dfn> using a {{XRLayerInit/layout}} |layout|, a {{XRTextureType}} |textureType|, a {{XRWebGLRenderingContext}} |context| and a {{XRLayerInit}} |init|, the user agent MUST run the following steps:
  1. let |array| be a new array.
  1. If |layout| is {{XRLayerLayout/mono}}:
        <dl class="switch">
        <dt> If |textureType| is {{"texture-array"}}:
          <dd> Initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_2D_ARRAY}} texture with 1 internal texture using |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
        <dt> Otherwise
          <dd> Initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_2D}} texture with |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
        <dl>
  1. let |numViews| be the number of all the session's {{XRView|XRViews}}.
  1. If |layout| is {{XRLayerLayout/stereo}}:
        <dl class="switch">
        <dt> If |textureType| is {{"texture-array"}}:
          <dd> Initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_2D_ARRAY}} texture with |numViews| internal textures using |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
          <dd> Return |array| and abort these steps.
        <dt> Otherwise
          <dd> Initialize |array| with |numViews| new instances of {{WebGLTexture}} created as a {{TEXTURE_2D}} texture with |context| and |init|'s {{XRProjectionLayerInit/alpha}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
          <dd> Return |array| and abort these steps.
        </dl>
  1. If |layout| is {{XRLayerLayout/stereo-left-right}}, initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_2D}} texture using |context| and |init|'s {{XRLayerInit/alpha}}, double of {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
  1. If |layout| is {{XRLayerLayout/stereo-top-bottom}}, initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_2D}} texture using |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/viewPixelWidth}} and double of {{XRLayerInit/viewPixelHeight}} values.
  1. return |array|.

</div>

<div class="algorithm" data-algorithm="allocate depth textures">

To <dfn>allocate depth textures</dfn> using a {{XRLayerInit/layout}} |layout|, a {{XRTextureType}} |textureType|, a {{XRWebGLRenderingContext}} |context| and a {{XRLayerInit}} |init|, the user agent MUST run the following steps:
  1. let |array| be a new array.
  1. If |init|'s {{XRLayerInit/depth}} and {{XRLayerInit/stencil}} are not set, return |array| and abort these steps.
  1. let |depthsupport| be true if |context| is a {{WebGL2RenderingContext}} or the {{WEBGL_depth_texture}} extension is enabled in |context|.
  1. If |init|'s {{XRLayerInit/depth}} or {{XRLayerInit/stencil}} are set and |depthsupport| is false, throw {{InvalidStateError}} and abort these steps.
  1. let |numViews| be the number of all the session's {{XRView|XRViews}}.
  1. If |layout| is {{XRLayerLayout/mono}}:
        <dl class="switch">
        <dt> If |textureType| is {{"texture-array"}}:
        <dd> Initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_2D_ARRAY}} texture with 1 internal texture using |context| and |init|'s {{XRLayerInit/stencil}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
        <dt> Otherwise
        <dd> Initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_2D}} texture with |context| and |init|'s {{XRLayerInit/stencil}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
  1. If |layout| is {{XRLayerLayout/stereo}}:
        <dl class="switch">
        <dt> If |textureType| is {{"texture-array"}}:
        <dd> Initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_2D_ARRAY}} texture with |numViews| internal textures using |context| and |init|'s {{XRLayerInit/stencil}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
        <dd> Return |array| and abort these steps.
        <dt> Otherwise
        <dd> Initialize |array| with |numViews| new instances of {{WebGLTexture}} created as a {{TEXTURE_2D}} texture with |context| and |init|'s {{XRLayerInit/stencil}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
        <dd> Return |array| and abort these steps.
        </dl>
  1. If |layout| is {{XRLayerLayout/stereo-left-right}}, initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_2D}} texture using |context| and |init|'s {{XRLayerInit/stencil}}, double of {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
  1. If |layout| is {{XRLayerLayout/stereo-top-bottom}}, initialize |array| with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_2D}} texture using |context| and |init|'s {{XRLayerInit/stencil}}, {{XRLayerInit/viewPixelWidth}} and double of {{XRLayerInit/viewPixelHeight}} values.
  1. return |array|.

</div>

<div class="algorithm" data-algorithm="createProjectionLayerAlgo">
The <dfn method for="XRWebGLBinding">createProjectionLayer(XRTextureType |textureType|, optional XRProjectionLayerInit |init|)</dfn> method creates a new {{XRProjectionLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. Let |session| be the target {{XRWebGLBinding}}'s [=XRWebGLBinding/session=].
  1. Let |context| be the target {{XRWebGLBinding}}'s [=XRWebGLBinding/context=].
  1. Let |bufferSize| be the [=recommended WebGL framebuffer resolution=] multiplied by |init|'s {{XRProjectionLayerInit/scaleFactor}}.
  1. Let |layer| be a new {{XRProjectionLayer}}
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw {{InvalidStateError}} and abort these steps.
  1. Initialize |layer|'s [=XRCompositionLayer/context=] to |context|.
  1. Initialize |layer|'s [=XRCompositionLayer/session=] to |session|.
  1. Initialize |layer|'s {{XRProjectionLayer/ignoreDepthValues}} as follows:
      <dl class="switch">
        <dt> If |init|'s {{XRProjectionLayerInit/depth}} value is <code>false</code> and the [=XR Compositor=] will make use of depth values
          <dd> Initialize |layer|'s {{XRProjectionLayer/ignoreDepthValues}} to <code>false</code>
        <dt> Otherwise
          <dd> Initialize |layer|'s {{XRProjectionLayer/ignoreDepthValues}} to <code>true</code>
      </dl>
  1. let |helperInit| be a new {{XRLayerInit}}.
  1. Initialize |helperInit|'s {{XRLayerInit/viewPixelWidth}} to |bufferSize| width.
  1. Initialize |helperInit|'s {{XRLayerInit/viewPixelHeight}} to |bufferSize| height.
  1. Initialize |helperInit|'s {{XRLayerInit/layout}} to {{XRLayerLayout/"stereo"}}
  1. Initialize |helperInit|'s {{XRLayerInit/depth}} to |init|'s {{XRProjectionLayerInit/depth}}.
  1. Initialize |helperInit|'s {{XRLayerInit/stencil}} to |init|'s {{XRProjectionLayerInit/stencil}}.
  1. Initialize |helperInit|'s {{XRLayerInit/alpha}} to |init|'s {{XRProjectionLayerInit/alpha}}.
  1. let |layout| be the result of [=determine the layout attribute|determining the layout attribute=] with |textureType|, |context| and |helperInit|.
  1. Initialize |layer|'s {{XRCompositionLayer/layout}} to |layout|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>true</code>.
  1. let |layer|'s [=colorTextures=] be the result of [=allocate color textures|allocating color textures=] with |layout|, |textureType|, |context| and |helperInit|.
  1. let |layer|'s [=depthStencilTextures=] be the result of [=allocate depth textures|allocating depth textures=] with |layout|, |textureType|, |context| and |helperInit|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. Return |layer|.

</div>

ISSUE: define "opaque" {{WebGLTexture}}

<div class="algorithm" data-algorithm="createQuadLayerAlgo">
The <dfn method for="XRWebGLBinding">createQuadLayer(XRTextureType |textureType|, XRQuadLayerInit |init|)</dfn> method creates a new {{XRQuadLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. If the device does not support the creation of an {{XRQuadLayer}}, throw an {{NotSupportedError}} and abort these steps.
  1. Let |session| be the target {{XRWebGLBinding}}'s [=XRWebGLBinding/session=].
  1. Let |context| be the target {{XRWebGLBinding}}'s [=XRWebGLBinding/context=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw {{InvalidStateError}} and abort these steps.
  1. Let |layer| be a new {{XRQuadLayer}}.
  1. Initialize |layer|'s [=XRCompositionLayer/context=] to |context|.
  1. Initialize |layer|'s [=XRCompositionLayer/session=] to |session|.
  1. Run [=initialize a quad layer=] with |layer| and |init|.
  1. Initialize |layer|'s {{XRCompositionLayer/layout}} to |layout|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>true</code>.
  1. let |layer|'s [=colorTextures=] be the result of [=allocate color textures|allocating color textures=] with |layout|, |textureType|, |context| and |init|.
  1. let |layer|'s [=depthStencilTextures=] be the result of [=allocate depth textures|allocating depth textures=] with |layout|, |textureType|, |context| and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

<div class="algorithm" data-algorithm="createCylinderLayerAlgo">
The <dfn method for="XRWebGLBinding">createCylinderLayer(XRTextureType |textureType|, XRCylinderLayerInit |init|)</dfn> method creates a new {{XRCylinderLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. If the device does not support the creation of an {{XRCylinderLayer}}, throw an {{NotSupportedError}} and abort these steps.
  1. Let |session| be the target {{XRWebGLBinding}}'s [=XRWebGLBinding/session=].
  1. Let |context| be the target {{XRWebGLBinding}}'s [=XRWebGLBinding/context=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw {{InvalidStateError}} and abort these steps.
  1. Let |layer| be a new {{XRCylinderLayer}}.
  1. Initialize |layer|'s [=XRCompositionLayer/context=] to |context|.
  1. Initialize |layer|'s [=XRCompositionLayer/session=] to |session|.
  1. Run [=initialize a cylinder layer=] with |layer| and |init|.
  1. let |layout| be the result of [=determine the layout attribute|determining the layout attribute=] with |textureType|, |context| and |init|.
  1. Initialize |layer|'s {{XRCompositionLayer/layout}} to |layout|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>true</code>.
  1. let |layer|'s [=colorTextures=] be the result of [=allocate color textures|allocating color textures=] with |layout|, |textureType|, |context| and |init|.
  1. let |layer|'s [=depthStencilTextures=] be the result of [=allocate depth textures|allocating depth textures=] with |layout|, |textureType|, |context| and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

<div class="algorithm" data-algorithm="createEquirectLayerAlgo">
The <dfn method for="XRWebGLBinding">createEquirectLayer(XRTextureType |textureType|, XREquirectLayerLayerInit |init|)</dfn> method creates a new {{XREquirectLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. If the device does not support the creation of an {{XREquirectLayer}}, throw an {{NotSupportedError}} and abort these steps.
  1. Let |session| be the target {{XRWebGLBinding}}'s [=XRWebGLBinding/session=].
  1. Let |context| be the target {{XRWebGLBinding}}'s [=XRWebGLBinding/context=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw {{InvalidStateError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} is not an instance of type {{XRReferenceSpace}}, throw {{InvalidStateError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} has a [=XRReferenceSpace/type=] of {{XRReferenceSpaceType/"viewer"}}, throw {{InvalidStateError}} and abort these steps.
  1. Let |layer| be a new {{XREquirectLayer}}.
  1. Initialize |layer|'s [=XRCompositionLayer/context=] to |context|.
  1. Initialize |layer|'s [=XRCompositionLayer/session=] to |session|.
  1. Run [=initialize a equirect layer=] with |layer| and |init|.
  1. let |layout| be the result of [=determine the layout attribute|determining the layout attribute=] with |textureType|, |context| and |init|.
  1. Initialize |layer|'s {{XRCompositionLayer/layout}} to |layout|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>true</code>.
  1. let |layer|'s [=colorTextures=] be the result of [=allocate color textures|allocating color textures=] with |layout|, |textureType|, |context| and |init|.
  1. let |layer|'s [=depthStencilTextures=] be the result of [=allocate depth textures|allocating depth textures=] with |layout|, |textureType|, |context| and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

<div class="algorithm" data-algorithm="createCubeLayerAlgo">
The <dfn method for="XRWebGLBinding">createCubeLayer(XRCubeLayerInit |init|)</dfn> method creates a new {{XRCubeLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. If the device does not support the creation of an {{XRCubeLayer}}, throw an {{NotSupportedError}} and abort these steps.
  1. Let |session| be the target {{XRWebGLBinding}}'s [=XRWebGLBinding/session=].
  1. Let |context| be the target {{XRWebGLBinding}}'s [=XRWebGLBinding/context=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is not a {{WebGL2RenderingContext}} context, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw {{InvalidStateError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} is not an instance of type {{XRReferenceSpace}}, throw {{InvalidStateError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} has a [=XRReferenceSpace/type=] of {{XRReferenceSpaceType/"viewer"}}, throw {{InvalidStateError}} and abort these steps.
  1. Let |layer| be a new {{XRCubeLayer}}.
  1. Initialize |layer|'s [=XRCompositionLayer/context=] to |context|.
  1. Initialize |layer|'s [=XRCompositionLayer/session=] to |session|.
  1. Let |layer|'s {{XRCubeLayer/space}} be the |init|'s {{XRLayerInit/space}}.
  1. Initialize |layer|'s {{XRCubeLayer/orientation}} as follows:
    <dl class="switch">
      <dt class="switch">If |init|'s {{XRCubeLayerInit/orientation}} is set
      <dd> Let |layer|'s {{XRCubeLayer/orientation}} be the result of running {{DOMPointReadOnly/fromPoint}} with |init|'s {{XRCubeLayerInit/orientation}}.
      <dt> Otherwise
      <dd> Let |layer|'s {{XRCubeLayer/orientation}} be a new {{DOMPointReadOnly}}.
    </dl>
  1. let |layout| be |init|'s {{XRLayerInit/layout}}.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>true</code>.
  1. If |layout| is {{XRLayerLayout/"stereo-left-right"}} or {{XRLayerLayout/"stereo-top-bottom"}}, throw {{InvalidStateError}} and abort these steps.
  1. Let |layer|'s [=colorTextures=] be a new array.
  1. let |numViews| be the number of all the session's {{XRView|XRViews}}.
  1. Initialize |layer|'s [=colorTextures=] as follows, based on the value of |layout|:
    <dl class="switch">
      <dt> {{XRLayerLayout/"mono"}}:
        <dd> Initialize [=colorTextures=] with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_CUBE_MAP}} texture with |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
      <dt> Otherwise
        <dd> Initialize [=colorTextures=] with |numViews| new instances of {{WebGLTexture}} created as a {{TEXTURE_CUBE_MAP}} texture with |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
    </dl>
  1. Let |layer|'s [=depthStencilTextures=] be a new array.
  1. If |init|'s {{XRLayerInit/depth}} and {{XRLayerInit/stencil}} are set, initialize |layer|'s [=depthStencilTextures=] as follows:
    <dl class="switch">
      <dt> If |context| is not a {{WebGL2RenderingContext}} and the {{WEBGL_depth_texture}} extension is not enabled in |context|.
        <dd> Throw {{InvalidStateError}} and abort these steps.
      <dt> Else if |layout| is {{XRLayerLayout/"mono"}}:
        <dd> Initialize [=depthStencilTextures=] with 1 new instance of {{WebGLTexture}} created as a {{TEXTURE_CUBE_MAP}} texture with |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
      <dt> Otherwise
        <dd> Initialize [=depthStencilTextures=] with |numViews| new instances of {{WebGLTexture}} created as a {{TEXTURE_CUBE_MAP}} texture with |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
    </dl>
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

ISSUE: Define how cubemap sizes are determined.

ISSUE: How should space be handled. Can you walk to the edge of a cubemap?

ISSUE: determine the initial state of {{XRCubeLayer/orientation}}.

<div class="algorithm" data-algorithm="validate the state of the XRWebGLSubImage creation function">

To <dfn>validate the state of the XRWebGLSubImage creation function</dfn> of a {{XRWebGLBinding}} |binding| with parameters of {{XRCompositionLayer}} |layer| and {{XRFrame}} |frame|, the user agent MUST run the following steps:
  1. If |frame|'s {{XRFrame/session}} is not equal to |layer|'s [=XRCompositionLayer/session=], return <code>false</code> and abort these steps.
  1. If |frame|'s [=XRFrame/active=] boolean is <code>false</code>, return <code>false</code> and abort these steps.
  1. If |frame|'s [=XRFrame/animationFrame=] boolean is <code>false</code>, return <code>false</code> and abort these steps.
  1. If |binding|'s [=XRWebGLBinding/session=] is not equal to |layer|'s [=XRCompositionLayer/session=], return <code>false</code> and abort these steps.
  1. If |binding|'s [=XRWebGLBinding/context=] is not equal to |layer|'s [=XRCompositionLayer/context=], return <code>false</code> and abort these steps.
  1. If the |layer|'s [=colorTextures=] array is empty or missing, return <code>false</code> and abort these steps.
  1. return <code>true</code>.

</div>

<div class="algorithm" data-algorithm="getSubImageAlgo">
The <dfn method for="XRWebGLBinding">getSubImage(XRCompositionLayer |layer|, XRFrame |frame|)</dfn> method creates a new {{XRWebGLSubImage}}.

When this method is invoked on a {{XRWebGLBinding}} |binding|, it MUST run the following steps:

  1. Initialize |subimage| as follows:
    <dl class="switch">
      <dt> If {{XRWebGLBinding/getSubImage()}} was called previously with the same |binding| and |layer|, the user agent MAY:
        <dd> Let |subimage| be the same {{XRWebGLSubImage}} object as returned by an earlier call with the same arguments.
      <dt> Otherwise
        <dd> Let |subimage| be a new {{XRWebGLSubImage}}.
    </dl>
  1. If |layer|'s {{XRCompositionLayer/layout}} attribute is {{XRLayerLayout/"stereo"}}, throw an {{InvalidStateError}} and abort these steps.
  1. If [=validate the state of the XRWebGLSubImage creation function=] with |layer| and |frame| is <code>false</code>, throw an {{InvalidStateError}} and abort these steps.
  1. Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} with the first element of the |layer|'s [=colorTextures=] array.
  1. If the layer has a depthStencilTexture, initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with the first element of the |layer|'s [=depthStencilTextures=] array.
  1. Set {{XRCompositionLayer/needsRedraw}} to <code>false</code>.
  1. return |subimage|.

</div>

<div class="algorithm" data-algorithm="getViewSubImageAlgo">
The <dfn method for="XRWebGLBinding">getViewSubImage(XRCompositionLayer |layer|, XRView |view|)</dfn> method creates a new {{XRWebGLSubImage}}.

When this method is invoked on a {{XRWebGLBinding}} |binding|, it MUST run the following steps:

  1. Initialize |subimage| as follows:
    <dl class="switch">
      <dt> If {{XRWebGLBinding/getViewSubImage()}} was called previously with the same |binding|, |layer| and |view|, the user agent MAY:
        <dd> Let |subimage| be the same {{XRWebGLSubImage}} object as returned by an earlier call with the same arguments.
      <dt> Otherwise
        <dd> Let |subimage| be a new {{XRWebGLSubImage}}.
    </dl>
  1. let |frame| be |view|'s {{frame}}.
  1. If [=validate the state of the XRWebGLSubImage creation function=] with |layer| and |frame| is <code>false</code>, throw an {{InvalidStateError}} and abort these steps.
  1. let |index| be a new integer with the value <code>0</code>.
  1. If |view|'s {{XRView/eye}} attribute is {{XREye/"right"}}, set |index| to <code>1</code>.
  1. Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} as follows:
    <dl class="switch">
      <dt class="switch">If the |layer| was created with a textureType of {{"texture-array"}}
      <dd> Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} with the first element of the |layer|'s [=colorTextures=] array.
      <dd> Initialize |subimage|'s {{XRWebGLSubImage/imageIndex}} with |index|.
      <dt> Otherwise
      <dd> Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} with the element at offset |index| of the |layer|'s [=colorTextures=] array.
    </dl>
  1. Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} as follows:
    <dl class="switch">
      <dt class="switch">If the |layer|'s [=depthStencilTextures=] is an empty array.
      <dd> Continue to the next entry.
      <dt> Else if the |layer| was created with a textureType of {{"texture-array"}}
      <dd> Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with the element at offset |index| of the |layer|'s [=depthStencilTextures=] array.
      <dt> Otherwise
      <dd> Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with the element of the |layer|'s [=depthStencilTextures=] array that corresponds to the |view|.
    </dl>
  1. Set {{XRCompositionLayer/needsRedraw}} to <code>false</code>.
  1. return |subimage|

</div>


Video layer creation {#videolayer}
====================

XRMediaLayerInit {#xrmedialayerinittype}
----------------
The {{XRMediaLayerInit}} dictionary represents a set of configurable values that describe how a {{XRCompositionLayer}} containing a video
is initialized.

<pre class="idl">
dictionary XRMediaLayerInit {
  required XRSpace space;
  XRLayerLayout layout = "mono";
  boolean invertStereo = false;
};
</pre>

The <dfn dict-member for="XRMediaLayerInit">space</dfn> attribute defines the spatial relationship with the user’s physical environment.

The <dfn dict-member for="XRMediaLayerInit">layout</dfn> attribute defines the layout of the video in the {{XRCompositionLayer}}.

The <dfn dict-member for="XRMediaLayerInit">invertStereo</dfn> attribute defines if the natural location of each view in the video
should be inverted.

XRMediaBinding {#xrmediabindingtype}
--------------
The {{XRMediaBinding}} object is used to create layers that display the content of an {{HTMLVideoElement}}.

<pre class="idl">
interface XRMediaBinding {
  constructor(XRSession session);

  XRQuadLayer createQuadVideoLayer(HTMLVideoElement video,
                                   optional XRMediaLayerInit init = {});
  XRCylinderLayer createCylinderVideoLayer(HTMLVideoElement video,
                                           optional XRMediaLayerInit init = {});
  XREquirectLayer createEquirectVideoLayer(HTMLVideoElement video,
                                           optional XRMediaLayerInit init = {});
};

</pre>

Each {{XRMediaBinding}} has an associated <dfn dfn-for="XRMediaBinding">session</dfn>, which is the
{{XRSession}} it was created with.

NOTE: It is possible to create more than one {{XRMediaBinding}}. The lifetime of a layer is not tied
to the lifetime of the {{XRMediaBinding}} that created it.

Each layer created through {{XRMediaBinding}} has an internal {{HTMLVideoElement}} [=XRCompositionLayer/media=].
If the layer is part of the session's {{XRSession/renderState}}, it will display the current frame of the video. The
layer is update at the native framerate of the [=/XR device=] or the video, whichever is less.

NOTE: only the video frames will be displayed in the layer. Video controls should be implemented by the author and must
be drawn in another layer.

ISSUE: more clarification is needed on how the video is blitted to the layers.

<div class="algorithm" data-algorithm="render-media-layer">
When an {{XRCompositionLayer}} |layer| with a {{HTMLVideoElement}} |media| needs to be rendered, the user agent
MUST run the following steps:
  1. Let |usability| be the result of [=check the usability of the image argument|checking the usability of=] |media|.
  1. If |usability| is <code>bad</code>, then fill the |layer| with opaque black and abort these steps.
  1. Fill the |layer| with the content of the |media| element.

<!--
-> maybe this is needed later
  1. Render the |layer| as follows:
    <dl class="switch">
      <dt class="switch">If the |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/"mono"}}
      <dd> Fill the |layer| with the
      <dt> Else if the |layer| was created with a textureType of {{"texture-array"}}
      <dd> Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with the element at offset |index| of the |layer|'s [=depthStencilTextures=] array.
      <dt> Otherwise
      <dd> Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with the element of the |layer|'s [=depthStencilTextures=] array that corresponds to the |view|.
    </dl>
-->
</div>

ISSUE: add a better algorithm to describe the drawing.

<div class="algorithm" data-algorithm="construct-media-binding">

The <dfn constructor for="XRMediaBinding">XRMediaBinding(XRSession |session|)</dfn> constructor
MUST perform the following steps when invoked:

  1. If |session|'s [=ended=] value is <code>true</code>, throw an {{InvalidStateError}} and abort these steps.
  1. If |session| is not an [=immersive session=], throw an {{InvalidStateError}} and abort these steps.
  1. Let |binding| be a new {{XRMediaBinding}}
  1. Initialize |binding|'s [=XRMediaBinding/session=] to |session|.
  1. Return |binding|.

</div>

<div class="algorithm" data-algorithm="createMediaQuadLayerAlgo">
The <dfn method for="XRMediaBinding">createQuadLayer(HTMLVideoElement |video|, optional XRMediaLayerInit |init|)</dfn> method creates a new {{XRQuadLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. If the device does not support the creation of an {{XRQuadLayer}}, throw an {{NotSupportedError}} and abort these steps.
  1. Let |session| be the target {{XRMediaBinding}}'s [=XRMediaBinding/session=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. Let |layer| be a new {{XRQuadLayer}}.
  1. Initialize |layer|'s [=XRCompositionLayer/session=] to |session|.
  1. Initialize |layer|'s [=XRCompositionLayer/media=] to |video|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>false</code>.
  1. Run [=initialize a quad layer=] with |layer| and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

<div class="algorithm" data-algorithm="createMediaCylinderLayerAlgo">
The <dfn method for="XRMediaBinding">createCylinderLayer(HTMLVideoElement |video|, optional XRMediaLayerInit |init|))</dfn> method creates a new {{XRCylinderLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. If the device does not support the creation of an {{XRCylinderLayer}}, throw an {{NotSupportedError}} and abort these steps.
  1. Let |session| be the target {{XRMediaBinding}}'s [=XRMediaBinding/session=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. Let |layer| be a new {{XRCylinderLayer}}.
  1. Initialize |layer|'s [=XRCompositionLayer/session=] to |session|.
  1. Initialize |layer|'s [=XRCompositionLayer/media=] to |video|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>false</code>.
  1. Run [=initialize a cylinder layer=] with |layer| and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

<div class="algorithm" data-algorithm="createMediaEquirectLayerAlgo">
The <dfn method for="XRMediaBinding">createEquirectLayer(HTMLVideoElement |video|, optional XRMediaLayerInit |init|)))</dfn> method creates a new {{XREquirectLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. If the device does not support the creation of an {{XREquirectLayer}}, throw an {{NotSupportedError}} and abort these steps.
  1. Let |session| be the target {{XRMediaBinding}}'s [=XRMediaBinding/session=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} is not an instance of type {{XRReferenceSpace}}, throw {{InvalidStateError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} has a [=XRReferenceSpace/type=] of {{XRReferenceSpaceType/"viewer"}}, throw {{InvalidStateError}} and abort these steps.
  1. Let |layer| be a new {{XREquirectLayer}}.
  1. Initialize |layer|'s [=XRCompositionLayer/session=] to |session|.
  1. Initialize |layer|'s [=XRCompositionLayer/media=] to |video|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>false</code>.
  1. Run [=initialize a equirect layer=] with |layer| and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

ISSUE: define how the {{XREquirectLayer}}'s parameters affect the video display.

Events {#events}
======

XRLayerEvent {#xrlayerevent-interface}
--------------

{{XRLayerEvent}} is fired to indicate changes to the state of an {{XRLayer}}.

<pre class="idl">
[SecureContext, Exposed=Window]
interface XRLayerEvent : Event {
  constructor(DOMString type, XRLayerEventInit eventInitDict);
  [SameObject] readonly attribute XRLayer layer;
};

dictionary XRLayerEventInit : EventInit {
  required XRLayer layer;
};
</pre>

The <dfn attribute for="XRLayerEvent">layer</dfn> attribute indicates the {{XRLayer}} that generated the event.

Event Types {#event-types}
-----------

The user agent MUST provide the following new events. Registration for and firing of the events must follow the usual behavior of DOM4 Events.

The user agent MAY fire a <dfn event for="XRLayer">redraw</dfn> event on the {{XRLayer}} object when [=the underlying resources of a layer are lost=] or
when the [=XR Compositor=] can no longer reproject the layer.

The author SHOULD redraw the content of the layer at the next [=XR animation frame=]. The event must be of type {{XRLayerEvent}}.

WebXR Device API Integration {#webxrintegration}
============================

XRRenderState changes {#xrrenderstatechanges}
---------------------
This module extends the {{XRRenderStateInit}} and {{XRRenderState}} interfaces with a new optional array {{XRRenderStateInit/layers}} containing
instances of {{XRLayer}}.

<pre class="idl">
[SecureContext, Exposed=Window] partial interface XRRenderState {
  [SameObject] readonly attribute FrozenArray&lt;XRLayer&gt;? layers;
};
</pre>

The <dfn attribute for="XRRenderState">layers</dfn> attribute returns an array containing
the instances of {{XRLayer}} that are displayed by the [=XR Compositor=].

<div class="algorithm" data-algorithm="initialize-renderstate-for-layers">
This module replaces the steps given by [=initialize the render state=]. Instead when an {{XRRenderState}} object |state|
is created for an {{XRSession}} |session|, the user agent MUST <dfn dfn-for="layers">initialize the render state</dfn> by running the following steps:
  1. Initialize |state| by running the original steps to [=initialize the render state=].
  1. Initialize |state|'s {{XRRenderState/layers}} as follows:
    <dl class="switch">
      <dt class="switch">If the |session| was created with "[=feature descriptor/layers=]" enabled
      <dd> Initialize |state|'s {{XRRenderState/layers}} with a new empty array.
      <dt> Otherwise
      <dd> set |state|'s {{XRRenderState/layers}} to <code>null</code>.
    </dl>

</div>

updateRenderState changes {#updaterenderstatechanges}
-------------------------

<div class="algorithm" data-algorithm="update-layers-state-for-layers">

This module replaces the steps given by "[=update the pending layers state=]". Instead when the user agent will
<dfn dfn-for="layers">update the pending layers state</dfn> with {{XRSession}} |session| and {{XRRenderStateInit}} |newState|, it must run the following steps:
  1. If the |session| was not created with "[=feature descriptor/layers=]" enabled:
    1. If {{XRRenderStateInit/layers}} is not <code>null</code>, throw an {{NotSupportedError}}.
    1. Abort these steps.
  1. If |newState|'s {{XRRenderStateInit/baseLayer}} is set, throw a {{InvalidStateError}} and abort these steps.
  1. If |newState|'s {{XRRenderStateInit/layers}} contains duplicate instances, throw an {{InvalidStateError}} and abort these steps.
  1. For each |layer| in |newState|'s {{XRRenderStateInit/layers}}:
    1. If |layer| is a {{XRCompositionLayer}} and |layer|'s [=XRCompositionLayer/session=] is different from |session|, throw an {{InvalidStateError}} and abort these steps.
    1. If |layer| is a {{XRWebGLLayer}} and |layer|'s [=XRWebGLLayer/session=] is different from |session|, throw an {{InvalidStateError}} and abort these steps.
  1. Let |activeState| be |session|'s [=active render state=].
  1. If |session|'s [=pending render state=] is <code>null</code>, set it to a copy of |activeState|.
  1. If |newState|'s {{XRRenderStateInit/layers}} array is set, set |session|'s [=pending render state=]'s {{XRRenderState/layers}} to |newState|'s {{XRRenderStateInit/layers}}.

</div>


Security and Privacy Considerations {#security}
===============================================

Timing of the composition {#xrcompositiontiming}
-------------------------

Composition timing MUST be independent of the content that is rendered.
Moreover, content in a layer MUST not be observable in other layers.

If possible, composition of layers should happen outside the browser to reduce risk of timing attacks or other security vulnerabilities.
