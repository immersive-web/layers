<pre class="metadata">
Shortname: webxrlayers
Title: WebXR Layers API Level 1
Group: immersivewebwg
Status: ED
TR: https://www.w3.org/TR/webxrlayers-1/
ED: https://immersive-web.github.io/layers/
Previous Version:
Repository: immersive-web/layers
Level: 1
Mailing List Archives: https://lists.w3.org/Archives/Public/public-immersive-web/

Editor: Rik Cabanier 106988, Facebook https://oculus.com, cabanier@fb.com

Abstract: This specification describes support for various layer types used in a WebXR session.
</pre>

<pre class="link-defaults">
spec:infra;
    type: dfn; text:string
spec: permissions-request-1;
    type: dfn; text: request(permissionDesc); for: Permissions
spec: webxr-1;
    type: dfn; text: immersive xr device; for: XR
    type: dfn; text: xr device; for: /
    type: dfn; text: active; for: XRFrame
    type: dfn; text: eye; for: XRView
    type: dfn; text: initialize the render state
    type: dfn; text: active render state
    type: dfn; text: pending render state
    type: dfn; text: apply the pending render state
    type: dfn; text: viewer reference space
    type: dfn; text: xr animation frame
    type: dfn; text: immersive xr device
    type: dfn; text: list of views; for: XRSession/viewer reference space
    type: dfn; text: list of viewports
    type: dfn; text: opaque framebuffer
    type: dfn; text: feature descriptor
    type: dfn; text: feature requirement
    type: dfn; text: active immersive session
    type: dfn; text: type; for: XRReferenceSpace
    type: dfn; text: session; for: XRSpace
    type: dfn; text: view
    type: dfn; text: XRLayer
    type: dfn; text: XRReferenceSpace
    type: dfn; text: type; for: XRReferenceSpace
    type: dfn; text: updateRenderState; for: XRSession
    type: dfn; text: session; for: XRWebGLLayer
    type: dfn; text: layers; for: XRRenderStateInit
spec: webxr-ar-module-1;
    type: dfn; text: first-person observer view
    type: dfn; text: secondary-views
spec: html;
    type: dfn; text: check the usability of the image argument
    type: dfn; text: request the xr permission
spec:webidl;
    type:dfn; text:new
</pre>

<pre class="anchors">
spec: WebXR Device API - Level 1; urlPrefix: https://www.w3.org/TR/webxr/#
    type: dfn; text: feature descriptor
    type: dfn; text: xr compositor
    type: dfn; text: recommended WebGL framebuffer resolution
    type: dfn; text: native WebGL framebuffer resolution
    type: dfn; text: immersive session
    type: dfn; text: xr compatible
    type: dfn; text: ended
    type: dfn; text: context
    type: dfn; text: XRFrame/active
    type: dfn; text: XRView/active
    type: dfn; text: eye; for: XRView
    type: dfn; text: frame
    type: dfn; text: animationFrame; for: XRFrame
    type: dfn; text: XRSession/requestAnimationFrame()
spec: WebGL; urlPrefix: https://www.khronos.org/registry/webgl/specs/latest/1.0/
    type: interface; text: WebGLFramebuffer; url: WebGLFramebuffer
    type: interface; text: WebGLTexture; url: WebGLTexture
    type: interface; text: WebGLRenderingContext; url: WebGLRenderingContext
    type: interface; text: WebGLRenderingContextBase; url: WebGLRenderingContextBase
    type: interface; text: GLenum
    type: typedef; text: TEXTURE_2D; url: 5.14
    type: typedef; text: TEXTURE_CUBE_MAP; url: 5.14
    type: method; text: clear; url: 5.14.11
    type: method; text: drawArrays; url: 5.14.11
    type: method; text: drawElements; url: 5.14.11
    type: dfn; text: WebGL viewport; url:#5.14.4
spec: WebGL 2.0; urlPrefix: https://www.khronos.org/registry/webgl/specs/latest/2.0/
    type: interface; text: WebGL2RenderingContext; url: WebGL2RenderingContext
    type: typedef; text: TEXTURE_2D_ARRAY; url: 3.7
    type: dfn; text: texStorage2D; url: 3.7.6
    type: dfn; text: texStorage3D; url: 3.7.6
spec: WEBGL_depth_texture; urlPrefix: https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/
    type: typedef; text: WEBGL_depth_texture
spec:html; urlPrefix: https://html.spec.whatwg.org/multipage/
    type: dfn; text: current realm; url: webappapis.html#current
spec: ECMAScript; urlPrefix: https://tc39.github.io/ecma262/#
    type: dfn; text: Realm; url: realm
</pre>

<pre class=link-defaults>
    spec:webxr-ar-module-1; type:enum-value; text:"immersive-ar"
</pre>

<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">

<style>
  .unstable::before {
    content: "This section is not stable";
    display: block;
    font-weight: bold;
    text-align: right;
    color: red;
  }
  .unstable {
    border: thin solid pink;
    border-radius: .5em;
    padding: .5em;
    margin: .5em calc(-0.5em - 1px);
    background-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='300' height='290'><text transform='rotate(-45)' text-anchor='middle' font-family='sans-serif' font-weight='bold' font-size='70' y='210' opacity='.1'>Unstable</text></svg>");
    background-repeat: repeat;
    background-color: #FFF4F4;
  }
  .unstable h3:first-of-type {
    margin-top: 0.5rem;
  }

  .unstable.example:not(.no-marker)::before {
    content: "Example " counter(example) " (Unstable)";
    float: none;
  }

  .non-normative::before {
    content: "This section is non-normative.";
    font-style: italic;
  }
  .tg {
    border-collapse: collapse;
    border-spacing: 0;
  }
  .tg th {
    border-style: solid;
    border-width: 1px;
    background: #90b8de;
    color: #fff;
    font-family: sans-serif;
    font-weight: bold;
    border-color: grey;
  }
  .tg td {
    padding: 4px 5px;
    background-color: rgb(221, 238, 255);
    font-family: monospace;
    border-style: solid;
    border-width: 1px;
    border-color: grey;
    overflow: hidden;
    word-break: normal;
  }
</style>

Introduction {#intro}
============

<section class="non-normative">

The spec adds support of `composition` layers to the WebXR spec. The benefits of layers are as follows:

 * <b>Performance and judder</b> Composition layers are presented at the frame rate of the compositor (i.e. native refresh rate of HMD) rather than at the application frame rate.
    Even when the application is not updating the layer's rendering at the native refresh rate of the compositor, the compositor might be able to re-project the existing
    rendering to the proper pose. This results in smoother rendering and less judder. Another feature of layers is that each of them can have different resolution. This allows the
    application to scale down the main eye buffer resolution on low performance systems, but keeping essential information, such as text or a map, in its own layer at a higher
    resolution.

 * <b>Legibility/visual fidelity</b> The resolution for eye-buffers for 3D world rendering can be set to relatively low values especially on low performance systems. It would
    be impossible to render high fidelity content, such as text, in this case. Each layer may have its own resolution and it will be re-sampled only once by the compositor (in contrary
    to the traditional approach with rendering layers via WebGL where the layer's content got re-sampled at least twice: once when rendering into WebGL
    eye-buffer (and losing a lot of details due to limited eye-buffer resolution) and the second time by the compositor).

 * <b>Power consumption / battery life</b> Due to reduced rendering pipeline, the lack of double sampling and no need to update the layer's rendering each frame, the power
    consumption is expected to be improved.

 * <b>Latency</b> Pose sampling for composition layers may occur at the very end of the frame and then certain reprojection techniques could be used to update the layer's pose to
    match it with the most recent HMD pose. This may significantly reduce the effective latency for the layers' rendering and as a result improve overall experience.

ISSUE: how to do hit testing? Should it be done by the UA?

</section>


Terminology {#terminology}
-----------

Application flow {#applicationflow}
----------------

<section class="non-normative">

If an author wants to use GL layers, they have to go through these steps:
 1. For any layer type other than {{XRProjectionLayer}} request support through {{XRPermissionDescriptor/requiredFeatures}} or {{XRPermissionDescriptor/optionalFeatures}} in {{XRSystem/requestSession()}}.
 1. Create an {{XRWebGLBinding}} or {{XRMediaBinding}}.
 1. Create layers with these objects.
 1. Add the layers to {{XRRenderStateInit}} and call {{XRSession/updateRenderState()}}.
 1. During {{XRSession/requestAnimationFrame()}} for webgl layers, draw content each WebGL layer.

</section>

Initialization {#initialization}
==============

If an application wants to create layers other than of type {{XRProjectionLayer}} during a session,
the session MUST be requested with an appropriate [=feature descriptor=]. The string "<dfn for="feature descriptor">layers</dfn>" is introduced
by this module as a new valid [=feature descriptor=] for the WebXR Layers feature.

Layers of type {{XRProjectionLayer}} MUST always be supported, regardless if the [=feature descriptor=] was requested.


<div class="example">
The following code requests layers as an optional feature.

<pre highlight="js">
navigator.xr.requestSession('immersive-vr', {
    optionalFeatures: ['layers']
  }
</pre>
</div>

Layers are only supported for XRSessions created with XRSessionMode of {{XRSessionMode/"immersive-vr"}}
or {{XRSessionMode/"immersive-ar"}}. {{XRSessionMode/"inline"}} sessions MUST not support layers.

The "[=feature descriptor/layers=]" [=feature descriptor=] has a [=feature requirement=] that it cannot be enabled when there is an [=active immersive session=].

NOTE: This means that executing the {{Permissions/request(permissionDesc)}} API with "[=feature descriptor/layers=]" will
not enable layers support for the current active session.

Layer types {#xrlayertypes}
===========

Mono and stereo layers {#monovsstereo}
----------------------
A stereo layer MUST supply a different {{XRSubImage}} to render to for each view.

A mono layer MUST supply a single {{XRSubImage}} which is shown to each view.

The [=XR Compositor=] MUST ensure that layers are presented correctly in stereo to the observer.

XRLayerLayout {#xrlayerlayouttype}
-------------
The {{XRLayerLayout}} enum defines the layout of the layer.

<pre class="idl">
enum XRLayerLayout {
  "default",
  "mono",
  "stereo",
  "stereo-left-right",
  "stereo-top-bottom"
};
</pre>

 - A layout of <dfn enum-value for="XRLayerLayout">default</dfn> indicates that the layer can accomodate all the views of session’s [=list of views=].
 - A layout of <dfn enum-value for="XRLayerLayout">mono</dfn> indicates that the layer is mono.
 - A layout of <dfn enum-value for="XRLayerLayout">stereo</dfn> indicates that the layer is stereo.
 - A layout of <dfn enum-value for="XRLayerLayout">stereo-left-right</dfn> indicates that the layer is stereo and divided left to right.
 - A layout of <dfn enum-value for="XRLayerLayout">stereo-top-bottom</dfn> indicates that the layer is stereo and divided top to bottom.

NOTE: If an {{XRCompositionLayer}} is created with a {{XRLayerLayout/"default"}} or {{XRLayerLayout/"stereo"}} {{XRLayerLayout}}, it is highly recommended
that it is allocated with an {{XRTextureType/"texture-array"}} texture type.

Note: The {{XRLayerLayout/"stereo-left-right"}} and {{XRLayerLayout/"stereo-top-bottom"}} layouts are designed to minimize draw
calls for content that is already in stereo (for example stereo videos or images). Experiences that don't require such assets types
should use the {{XRLayerLayout/"default"}} or {{XRLayerLayout/"stereo"}} layout.

XRCompositionLayer {#xrcompositionlayertype}
--------------
XRCompositionLayer defines a set of common attributes and behaviors across certain layer types.

<pre class="idl">
interface XRCompositionLayer : XRLayer {
  readonly attribute XRLayerLayout layout;

  attribute boolean blendTextureSourceAlpha;
  attribute boolean? chromaticAberrationCorrection;
  attribute float? fixedFoveation;

  readonly attribute boolean needsRedraw;

  void destroy();
};
</pre>

The <dfn attribute for="XRCompositionLayer">layout</dfn> attribute returns the layout of the layer.

The <dfn attribute for="XRCompositionLayer">blendTextureSourceAlpha</dfn> attribute enables the layer’s texture alpha channel.

The <dfn attribute for="XRCompositionLayer">chromaticAberrationCorrection</dfn> attribute is a hint for the [=XR Compositor=] to
enable optical chromatic aberration correction for the layer. If the user agent or device does not support this attribute, they
should return <code>null</code> on getting, and setting should be a <code>no-op</code>.

The <dfn attribute for="XRCompositionLayer">fixedFoveation</dfn> attribute controls the amount of foveation used by the
[=XR Compositor=]. If the user agent or device does not support this attribute, they
should return <code>null</code> on getting, and setting should be a <code>no-op</code>.
Setting {{XRCompositionLayer/fixedFoveation}} to a value less than <code>0</code> will set it to <code>0</code> and setting it to
a value higher than <code>1</code> will set it to <code>1</code>. <code>0</code> sets the minimum amount of foveation while
<code>1</code> set the maximum. It is up to the user agent how the [=XR Compositor=] interprets these values.

The <dfn attribute for="XRCompositionLayer">needsRedraw</dfn> attribute signals that the {{XRCompositionLayer}} should be
rerendered in the next [=XR animation frame=]. It MAY be set when [=the underlying resources of a layer are lost=] or
when the [=XR Compositor=] can no longer reproject the layer. Failing to redraw the content in the next [=XR animation frame=]
might cause flickering or other side effects.

<div class="algorithm" data-algorithm="redrawLayerAlgo">
When <dfn>the underlying resources of a layer are lost</dfn> for an {{XRCompositionLayer}} |layer|,
the user agent MUST run the following steps:
  1. Set |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>true</code>.
  1. If |layer| is not an {{XRProjectionLayer}}, [=queue a task=] to [=fire an event=] named {{redraw}} on |layer|.

</div>

{{destroy()}} will delete the underlying attachments. If there are no attachments, this function does nothing.

<div class="algorithm" data-algorithm="intialization of a composition layer">

To <dfn>intialize a composition layer</dfn> with a {{XRSession}} |session| and an optional instance of a {{WebGLRenderingContext}}
or a {{WebGL2RenderingContext}} |context|, the user agent MUST run the following steps:
  1. Set [=this=] [=XRCompositionLayer/session=] to |session|.
  1. If |context| is defined, set [=this=] [=XRCompositionLayer/context=] to |context|.
  1. Set [=this=] {{XRCompositionLayer/blendTextureSourceAlpha}} to <code>true</code>.
  1. Initialize [=this=] {{XRCompositionLayer/chromaticAberrationCorrection}} as follows:
    <dl class="switch">
      <dt class="switch">If the user agent supports chromatic aberration correction
      <dd> Set [=this=] {{XRCompositionLayer/chromaticAberrationCorrection}} to <code>true</code> or <code>false</code> depending on the user agent's preference.
      <dt> Otherwise
      <dd> Set [=this=] {{XRCompositionLayer/chromaticAberrationCorrection}} to <code>null</code>.
    </dl>
  1. Initialize [=this=] {{XRCompositionLayer/fixedFoveation}} as follows:
    <dl class="switch">
      <dt class="switch">If the user agent supports fixed foveation
      <dd> Set [=this=] {{XRCompositionLayer/fixedFoveation}} to a value between <code>0</code> and <code>1</code> depending on the user agent's preference.
      <dt> Otherwise
      <dd> Set [=this=] {{XRCompositionLayer/fixedFoveation}} to <code>null</code>.
    </dl>

</div>

<div class="algorithm" data-algorithm="calling destroy on a layer">

When calling {{destroy()}}, the user agent MUST run the following steps:
  1. Set [=this=] [=colorTextures=] array to an empty array.
  1. Set [=this=] [=depthStencilTextures=] array to an empty array.
  1. Destroy the underlying GL attachments.

</div>

Each {{XRCompositionLayer}} has a <dfn for="XRCompositionLayer">context</dfn> object which is an instance
of either null or a {{WebGLRenderingContext}} or a {{WebGL2RenderingContext}} and a <dfn for="XRCompositionLayer">media</dfn>
object which is an instance of null or a {{HTMLVideoElement}}.

Each {{XRCompositionLayer}} has an associated <dfn for="XRCompositionLayer">session</dfn>, which is the
{{XRSession}} it was created with.

<!--
# we might need this at a later stage.

If the {{XRCompositionLayer}} was created by {{XRWebGLBinding}}, it MUST have a <dfn>list of viewports</dfn> which is a
[=/list=] containing one [=WebGL viewport=] for each {{XRView}} the {{XRSession}} currently exposes. The viewports MUST
have a {{XRViewport/width}} and {{XRViewport/height}} greater than <code>0</code> and MUST describe a rectangle that does
not exceed the bounds of the {{XRCompositionLayer}}.
-->

<div class="algorithm" data-algorithm="setting the space on a layer">

When <dfn>setting the space on a layer</dfn> with {{XRSpace}} |space| and {{XRCompositionLayer}} |layer|, the user agent MUST run the following steps to validate if the |space| is valid:
  1. If |space| is <code>null</code>, throw {{TypeError}} and abort these steps.
  1. If |space|'s [=XRSpace/session=] is not equal to the |layer|'s [=XRCompositionLayer/session=], throw {{TypeError}} and abort these steps.

</div>

{{XRCompositionLayer}} has an internal boolean <dfn for="XRCompositionLayer">isStatic</dfn> that indicates that the author can only draw
to this layer when {{XRCompositionLayer/needsRedraw}} is <code>true</code>.

NOTE: if [=XRCompositionLayer/isStatic=] is <code>true</code> the author can only draw into the layer once after creation or once after
a redraw event. This allows the UA to only allocate a single GPU buffer.

XRProjectionLayer {#xrprojectionlayertype}
-----------------
An {{XRProjectionLayer}} is a layer that fills the entire view of the observer.
Projection layers should be refreshed close to the device's native frame rate.

<pre class="idl">
interface XRProjectionLayer : XRCompositionLayer {
  readonly attribute boolean ignoreDepthValues;
};
</pre>

The <dfn attribute for="XRProjectionLayer">ignoreDepthValues</dfn> attribute, if <code>true</code>, indicates that the
[=XR Compositor=] MUST NOT make use of values in the depth buffer attachment when rendering. When the attribute
is <code>false</code> it indicates that the content of the depth buffer attachment will be used by the
[=XR Compositor=] and is expected to be representative of the scene rendered into the layer.

Each {{XRProjectionLayer}} has an internal {{WebGLTexture}} <dfn for="XRProjectionLayer">first-person observer color texture</dfn>
and an internal {{WebGLTexture}} <dfn for="XRProjectionLayer">first-person observer depth texture</dfn> that are used to render
the [=first-person observer view=].

XRQuadLayer {#xrquadlayertype}
-----------
An {{XRQuadLayer}} renders a layer that takes up a flat rectangular space in the virtual environment.
Only the front of the layer MUST be visible; the back face MUST not be drawn by the [=XR Compositor=].

A XRQuadLayer has no thicknes. It is a two-dimensional object positioned and oriented in 3D space. The position
of a quad refers to the center of the quad.

<pre class="idl">
interface XRQuadLayer : XRCompositionLayer {
  attribute XRSpace space;
  attribute XRRigidTransform transform;

  attribute float width;
  attribute float height;

  // Events
  attribute EventHandler onredraw;
};
</pre>

The <dfn attribute for="XRQuadLayer">transform</dfn> attributes sets and returns the offset and orientation relative to the
<dfn attribute for="XRQuadLayer">space</dfn> attribute. The {{XRQuadLayer/transform}} and {{XRQuadLayer/space}} attributes
establish the spatial relationship of the layer within the user’s physical environment.
When setting the {{XRQuadLayer/space}}, first run the steps for [=setting the space on a layer=].

The <dfn attribute for="XRQuadLayer">width</dfn> and <dfn attribute for="XRQuadLayer">height</dfn> attributes
set and return the width and height of the layer in meters.

<div class="algorithm" data-algorithm="initQuadLayerAlgo">
When <dfn lt="initialize a quad layer">initializing an {{XRQuadLayer}} |layer| with an {{XRQuadLayerInit}} |init|</dfn>, the user agent MUST run the following steps:
  1. Initialize |layer|'s {{XRQuadLayer/width}} to |init|'s {{XRQuadLayerInit/width}}.
  1. Initialize |layer|'s {{XRQuadLayer/height}} to |init|'s {{XRQuadLayerInit/height}}.
  1. Let |layer|'s {{XRQuadLayer/space}} be the |init|'s {{XRLayerInit/space}}.
  1. Initialize |layer|'s {{XRQuadLayer/transform}} as follows:
    <dl class="switch">
      <dt class="switch">If |init|'s {{XRQuadLayerInit/transform}} is set
      <dd> Let |layer|'s {{XRQuadLayer/transform}} be a [=new=] {{XRRigidTransform}} in the [=relevant realm=] of |layer| initialized with {{XRRigidTransform/position}} and {{XRRigidTransform/orientation}} of |init|'s {{XRQuadLayerInit/transform}}.
      <dt> Otherwise
      <dd> Let |layer|'s {{XRQuadLayer/transform}} be a [=new=] {{XRRigidTransform}} in the [=relevant realm=] of |layer| initialized with a {{DOMPointInit}} position of <code>{ x: 0.0, y: 0.0, z: 0.0, w: 1.0 }</code>.
    </dl>
  1. Initialize |layer|'s [=XRCompositionLayer/isStatic=] to |init|'s {{XRQuadLayerInit/isStatic}}

</div>

The <dfn attribute for="XRQuadLayer">onredraw</dfn> attribute is an Event handler IDL attribute for the {{redraw}} event type.

XRCylinderLayer {#xrcylinderayertype}
---------------
An {{XRCylinderLayer}} renders a layer that takes up a curved rectangular space in the virtual environment.
Only the front of the layer MUST be visible; the back face MUST not be drawn by the [=XR Compositor=].

A XRCylinderLayer has no thicknes. It is a two-dimensional object positioned and oriented in 3D space. The position
of the cylinder refers to the center of the quad.

<pre class="idl">
interface XRCylinderLayer : XRCompositionLayer {
  attribute XRSpace space;
  attribute XRRigidTransform transform;

  attribute float radius;
  attribute float centralAngle;
  attribute float aspectRatio;

  // Events
  attribute EventHandler onredraw;
};
</pre>

The <dfn attribute for="XRCylinderLayer">transform</dfn> attribute sets and returns the offset and orientation relative to the
<dfn attribute for="XRCylinderLayer">space</dfn> attribute. The {{XRCylinderLayer/transform}} and {{XRCylinderLayer/space}} attributes
establish the spatial relationship of the layer within the user’s physical environment.
When setting the {{XRCylinderLayer/space}}, first run the steps for [=setting the space on a layer=].

The <dfn attribute for="XRCylinderLayer">radius</dfn> attribute controls the radius in meters of the cylinder.

The <dfn attribute for="XRCylinderLayer">centralAngle</dfn> attribute controls the angle in radians of the visible section of the cylinder.
It grows symmetrically around the 0 angle.

The <dfn attribute for="XRCylinderLayer">aspectRatio</dfn> attribute controls the ratio of the visible cylinder section.

<img src="images/cylinder_layer_params.png" style="width:80%"/>

<div class="algorithm" data-algorithm="initCylinderLayerAlgo">
When <dfn lt="initialize a cylinder layer">initializing an {{XRCylinderLayer}} |layer| with an {{XRCylinderLayerInit}} |init|</dfn>, the user agent MUST run the following steps:
  1. Initialize |layer|'s {{XRCylinderLayer/radius}} to |init|'s {{XRCylinderLayerInit/radius}}.
  1. Initialize |layer|'s {{XRCylinderLayer/centralAngle}} to |init|'s {{XRCylinderLayerInit/centralAngle}}.
  1. Initialize |layer|'s {{XRCylinderLayer/aspectRatio}} to |init|'s {{XRCylinderLayerInit/aspectRatio}}.
  1. Let |layer|'s {{XRCylinderLayer/space}} be the |init|'s {{XRLayerInit/space}}.
  1. Initialize |layer|'s {{XRCylinderLayer/transform}} as follows:
    <dl class="switch">
      <dt class="switch">If |init|'s {{XRCylinderLayerInit/transform}} is set
      <dd> Let |layer|'s {{XRCylinderLayer/transform}} be a [=new=] {{XRRigidTransform}} in the [=relevant realm=] of |layer| initialized with {{XRRigidTransform/position}} and {{XRRigidTransform/orientation}} of |init|'s {{XRCylinderLayerInit/transform}}.
      <dt> Otherwise
      <dd> Let |layer|'s {{XRCylinderLayer/transform}} be a [=new=] {{XRRigidTransform}} in the [=relevant realm=] of |layer| initialized with a {{DOMPointInit}} position of <code>{ x: 0.0, y: 0.0, z: 0.0, w: 1.0 }</code>.
    </dl>
  1. Initialize |layer|'s [=XRCompositionLayer/isStatic=] to |init|'s {{XRCylinderLayerInit/isStatic}}

</div>

The <dfn attribute for="XRCylinderLayer">onredraw</dfn> attribute is an Event handler IDL attribute for the {{redraw}} event type.

XREquirectLayer {#xrequirectlayertype}
---------------
An {{XREquirectLayer}} renders a layer where the [=XR Compositor=] MUST map an equirectangular coded data onto the inside of a sphere.

ISSUE: this section needs clarification

<pre class="idl">
interface XREquirectLayer : XRCompositionLayer {
  attribute XRSpace space;
  attribute XRRigidTransform transform;

  attribute float radius;
  attribute float centralHorizontalAngle;
  attribute float upperVerticalAngle;
  attribute float lowerVerticalAngle;

  // Events
  attribute EventHandler onredraw;
};
</pre>

The <dfn attribute for="XREquirectLayer">transform</dfn> attribute sets and returns the offset and orientation relative to
{{XREquirectLayer/space}}. The {{XREquirectLayer/transform}} attribute and the {{XREquirectLayer/space}}
establish the spatial relationship of the layer within the user’s physical environment.

The <dfn attribute for="XREquirectLayer">radius</dfn> attribute is the non-negative radius in meters of the sphere. Values of <code>zero</code> or <code>infinity</code> are treated as an infinite sphere.

Setting {{XREquirectLayer/radius}} to a value less than <code>0</code> will set it to <code>0</code>.

The <dfn attribute for="XREquirectLayer">centralHorizontalAngle</dfn>, <dfn attribute for="XREquirectLayer">upperVerticalAngle</dfn>
and <dfn attribute for="XREquirectLayer">lowerVerticalAngle</dfn> attributes set and return how the texture is mapped to the sphere.

Setting {{XREquirectLayer/centralHorizontalAngle}} to a value less than 0 will set it to 0 and setting it to
a value higher than 2π will set it to 2π.

Setting {{XREquirectLayer/upperVerticalAngle}} or {{XREquirectLayer/lowerVerticalAngle}} to a value less than -π/2 will set it
to -π/2 and setting it to a value higher than π/2 will set it to π/2.

<img src="images/equirect.png" style="width:50%"/>

When assigning an {{XRSpace}} to the {{XREquirectLayer/space}} attribute, first run the following steps.

<div class="algorithm" data-algorithm="setting the space on an equirect layer">

When <var ignore>setting the space on an equirect layer</var> with {{XRSpace}} |space| and {{XREquirectLayer}} |layer|, the user agent MUST run the following steps to validate if the |space| is valid:
  1. If |init|'s {{XRLayerInit/space}} is not an instance of type {{XRReferenceSpace}}, throw {{TypeError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} has a [=XRReferenceSpace/type=] of {{XRReferenceSpaceType/"viewer"}}, throw {{TypeError}} and abort these steps.
  1. Run [=setting the space on a layer=] with |space| and |layer|.

</div>

<div class="algorithm" data-algorithm="initEquirectLayerAlgo">
When <dfn lt="initialize a equirect layer">initializing an {{XREquirectLayer}} |layer| with an {{XREquirectLayerInit}} |init|</dfn>, the user agent MUST run the following steps:
  1. Initialize |layer|'s {{XREquirectLayer/radius}} to |init|'s {{XREquirectLayerInit/radius}}.
  1. Initialize |layer|'s {{XREquirectLayer/centralHorizontalAngle}} to |init|'s {{XREquirectLayerInit/centralHorizontalAngle}}.
  1. Initialize |layer|'s {{XREquirectLayer/upperVerticalAngle}} to |init|'s {{XREquirectLayerInit/upperVerticalAngle}}.
  1. Initialize |layer|'s {{XREquirectLayer/lowerVerticalAngle}} to |init|'s {{XREquirectLayerInit/lowerVerticalAngle}}.
  1. Let |layer|'s {{XREquirectLayer/space}} be the |init|'s {{XRLayerInit/space}}.
  1. Initialize |layer|'s {{XREquirectLayer/transform}} as follows:
    <dl class="switch">
      <dt class="switch">If |init|'s {{XREquirectLayerInit/transform}} is set
      <dd> Let |layer|'s {{XREquirectLayer/transform}} be a [=new=] {{XRRigidTransform}} in the [=relevant realm=] of |layer| initialized with {{XRRigidTransform/position}} and {{XRRigidTransform/orientation}} of |init|'s {{XREquirectLayerInit/transform}}.
      <dt> Otherwise
      <dd> Let |layer|'s {{XREquirectLayer/transform}} be a [=new=] {{XRRigidTransform}} in the [=relevant realm=] of |layer|.
    </dl>
  1. Initialize |layer|'s [=XRCompositionLayer/isStatic=] to |init|'s {{XREquirectLayerInit/isStatic}}

</div>

The <dfn attribute for="XREquirectLayer">onredraw</dfn> attribute is an Event handler IDL attribute for the {{redraw}} event type.

XRCubeLayer {#xcubelayertype}
-----------
A {{XRCubeLayer}} renders a layer where the [=XR Compositor=] renders directly from a cubemap.

ISSUE: this section needs clarification

<pre class="idl">
interface XRCubeLayer : XRCompositionLayer {
  attribute XRSpace space;
  attribute DOMPointReadOnly orientation;

  // Events
  attribute EventHandler onredraw;
};
</pre>

The <dfn attribute for="XRCubeLayer">orientation</dfn> attribute sets and returns the orientation relative to the
<dfn attribute for="XRCubeLayer">space</dfn> attribute. The {{XRCubeLayer/orientation}} and {{XRCubeLayer/space}} attributes
establish the spatial relationship of the layer within the user’s physical environment.
When placing the {{XRCubeLayer}} only the orientation of the {{XRCubeLayer/space}} is considered. The cube layer will always be rendered
with the view point at the center.

When assigning an {{XRSpace}} to the {{XRCubeLayer/space}} attribute, first run the following steps.

<div class="algorithm" data-algorithm="setting the space on a cube layer">

When <var ignore>setting the space on an cube layer</var> with {{XRSpace}} |space| and {{XRCubeLayer}} |layer|, the user agent MUST run the following steps to validate if the |space| is valid:
  1. If |init|'s {{XRLayerInit/space}} is not an instance of type {{XRReferenceSpace}}, throw {{TypeError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} has a [=XRReferenceSpace/type=] of {{XRReferenceSpaceType/"viewer"}}, throw {{TypeError}} and abort these steps.
  1. Run [=setting the space on a layer=] with |space| and |layer|.

</div>

The <dfn attribute for="XRCubeLayer">onredraw</dfn> attribute is an Event handler IDL attribute for the {{redraw}} event type.

Spaces {#spaces}
======

{{XRProjectionLayer}} and {{XRWebGLLayer}} don't have associated an {{XRSpace}} because they render to the full frame.

{{XRCubeLayer}} and {{XREquirectLayer}} MUST only support {{XRReferenceSpace|XRReferenceSpaces}} that are not of type {{"viewer"}}.

{{XRQuadLayer}} and {{XRCylinderLayer}} MUST support all {{XRSpace}} types.

<section class="non-normative">

Generally, developers should not use of {{"viewer"}} space to stabilize layers, as this will almost always defeat positional or
rotational reprojection and result in a loss in stability of the rendered content relative to the world. The exception being small UI elements
like a gaze cursor or targeting reticle.

Following are some best practices of spaces to use with a layer type:
  - {{XRQuadLayer}} with {{"viewer"}} space: Head-locked constant-size reticle in center of screen.
  - {{XRQuadLayer}} or {{XRCylinderLayer}} in {{"local"}}, {{"unbounded"}} space: springy body-locked UI.
  - {{XRQuadLayer}} or {{XRCylinderLayer}} in {{"local"}}, {{"local-floor"}}, {{"unbounded"}}, {{"bounded-floor"}} or anchor space: world-locked video, placed by the user.
  - {{XREquirectLayer}} or {{XRCubeLayer}} in {{"local"}} space: 360-degree video or skybox.

</section>

Rendering {#rendering}
=========

XRSubImage {#xrsubimagetype}
----------
The {{XRSubImage}} object represents what viewport of the GPU texture to use.

<pre class="idl">
interface XRSubImage {
  [SameObject] readonly attribute XRViewport viewport;
};
</pre>

NOTE: this class is designed to accomodate future extensions

The <dfn attribute for="XRSubImage">viewport</dfn> attribute returns the {{XRViewport}} to use when rendering the sub image.

XRWebGLSubImage {#xrwebglsubimagetype}
---------------
The {{XRWebGLSubImage}} object is used during rendering of the layer.

<pre class="idl">
interface XRWebGLSubImage : XRSubImage {
  [SameObject] readonly attribute WebGLTexture colorTexture;
  [SameObject] readonly attribute WebGLTexture? depthStencilTexture;
  readonly attribute unsigned long? imageIndex;
  readonly attribute unsigned long textureWidth;
  readonly attribute unsigned long textureHeight;
};
</pre>

The <dfn attribute for="XRWebGLSubImage">colorTexture</dfn> attribute returns the color {{WebGLTexture}} for the {{XRCompositionLayer}}.

The <dfn attribute for="XRWebGLSubImage">depthStencilTexture</dfn> attribute returns the depth/stencil {{WebGLTexture}} for the {{XRCompositionLayer}}.
If the layer was created without depth/stencil, this attribute returns null.

The <dfn attribute for="XRWebGLSubImage">imageIndex</dfn> attribute returns the offset into the texture array. Valid only for layers
that were requested with {{texture-array}}.

The {{XRWebGLSubImage/colorTexture}} and {{XRWebGLSubImage/depthStencilTexture}} objects MUST only be used during the [=XR animation frame=] of the
current session and MUST be made invalid once the [=XR animation frame=] completes.

NOTE: the {{XRWebGLSubImage/colorTexture}} and {{XRWebGLSubImage/depthStencilTexture}} objects are allocated when the layer is contructed using the
[=allocate color textures=] and [=allocate depth textures=] algoritms. The side effect of this pre-allocation is that calling
{{XRWebGLBinding/getSubImage()}} and {{XRWebGLBinding/getViewSubImage()}} with the same parameters will always return the same texture objects.

In addition, they MUST behave as though they were allocated with [=texStorage2D=] or [=texStorage3D=], as appropriate,
even when using a WebGL 1.0 context.

NOTE: Changes to the dimensions or format of the {{XRWebGLSubImage/colorTexture}} or {{XRWebGLSubImage/depthStencilTexture}} objects are not allowed. GL commands
may only alter the texel values and texture parameters. Using any of the following
commands with the WebGLTexture will result in an INVALID_OPERATION error
being generated, even if it does not affect the dimensions or format: TexImage*, CompressedTexImage*, CopyTexImage* and TexStorage*.
The <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.0/es_spec_3.0.pdf#nameddest=section-3.8.4">"Immutable-Format Texture Images"</a>
section in the OpenGL ES 3.0 spec defines these limitations in more detail.

The <dfn attribute for="XRWebGLSubImage">textureWidth</dfn> and <dfn attribute for="XRWebGLSubImage">textureHeight</dfn> attributes
return the width and height in pixels of the GL attachments, respectively.

XRTextureType {#xrtexturetype}
-------------
The {{XRTextureType}} enum defines what type of texture is allocated.

<pre class="idl">
enum XRTextureType {
  "texture",
  "texture-array"
};
</pre>

- A texture type of <dfn enum-value for="XRTextureType">texture</dfn> indicates that the textures of {{XRWebGLSubImage}} MUST be of type {{TEXTURE_2D}}
- A texture type of <dfn enum-value for="XRTextureType">texture-array</dfn> indicates that the textures of {{XRWebGLSubImage}} MUST be of type {{TEXTURE_2D_ARRAY}}

GPU layer and view creation {#gpulayer}
===========================

Overview {#xrgpulayeroverview}
--------
<section class="non-normative">

When a layer is created it is backed by a GPU resource, typically a texture, provided by one of the Web platform's graphics APIs. In order to
specify which API is providing the layer's GPU resources an {{XRWebGLBinding}} for the API in question must be created.
Each graphics API may have unique requirements that must be satisfied before a context can be used in the creation of a layer. For example,
a {{WebGLRenderingContext}} must have its xrCompatible flag set prior to being passed to the constructor of the {{XRWebGLBinding}} instance.

Any interaction between the {{XRSession}} the graphics API, such as allocating or retrieving textures, will go through this {{XRWebGLBinding}} instance, and the exact mechanics
of the interaction will typically be API specific. This allows the rest of the WebXR API to be
graphics API agnostic and more easily adapt to future advances in rendering techniques.

Once an {{XRWebGLBinding}} instance has been acquired, it can be used to create a variety of {{XRCompositionLayer}}. Any layers created by that instance will then be able
to query the associated GPU resources each frame, generally expected to be the native API's texture interface.

The various layer types are created with the create____Layer series of methods on the {{XRWebGLBinding}} instance. Information about the graphics resources required,
such as whether or not to allocate a depth buffer or alpha channel, are passed in at layer creation time and will be immutable for the lifetime of the layer.
The method will return the associated XRCompositionLayer type.

Some layer types may not be supported by the {{XRSession}}. If a layer type isn't supported the method will throw an exception. {{XRProjectionLayer}} MUST be supported by all {{XRSession}}s.
</section>

XRProjectionLayerInit {#xrprojectionlayerinittype}
---------------------
The {{XRProjectionLayerInit}} dictionary represents a set of configurable values that describe how an {{XRProjectionLayer}}
is initialized.

<pre class="idl">
dictionary XRProjectionLayerInit {
  boolean depth = true;
  boolean stencil = false;
  boolean alpha = true;
  double scaleFactor = 1.0;
};
</pre>

The <dfn dict-member for="XRProjectionLayerInit">depth</dfn> attribute defines if the {{XRProjectionLayer}} will have a depth buffer.

The <dfn dict-member for="XRProjectionLayerInit">stencil</dfn> attribute defines if the {{XRProjectionLayer}} will have a stencil buffer.

The <dfn dict-member for="XRProjectionLayerInit">alpha</dfn> attribute defines if the {{XRProjectionLayer}} will have an alpha channel.

The <dfn dict-member for="XRProjectionLayerInit">scaleFactor</dfn> attribute defines the value that the |session|'s
[=recommended WebGL framebuffer resolution=] MUST be multiplied by determining the resolution of the layer's attachments.

XRLayerInit {#xrlayerinittype}
---------------------
The {{XRLayerInit}} dictionary represents a set of common configurable values for {{XRQuadLayer}}, {{XRCylinderLayer}},
{{XREquirectLayer}} and {{XRCubeLayer}} .

<pre class="idl">
dictionary XRLayerInit {
  required XRSpace space;
  required unsigned long viewPixelWidth;
  required unsigned long viewPixelHeight;
  XRLayerLayout layout = "mono";
  boolean depth = false;
  boolean stencil = false;
  boolean alpha = true;
};
</pre>

The <dfn dict-member for="XRLayerInit">space</dfn> attribute defines the spatial relationship with the user’s physical environment.

The <dfn dict-member for="XRLayerInit">viewPixelWidth</dfn> and <dfn dict-member for="XRLayerInit">viewPixelHeight</dfn> attributes define
the rectangular dimensions of the {{XRCompositionLayer}}.

The <dfn dict-member for="XRLayerInit">layout</dfn> attribute defines the layout of the layer.

The <dfn dict-member for="XRLayerInit">depth</dfn> attribute defines if the {{XRCompositionLayer}} view will have a depth buffer.

The <dfn dict-member for="XRLayerInit">stencil</dfn> attribute defines if the {{XRCompositionLayer}} view will have a stencil buffer.

The <dfn dict-member for="XRLayerInit">alpha</dfn> attribute defines if the {{XRCompositionLayer}} view will have an alpha channel.

XRQuadLayerInit {#xrquadlayerinit}
-------------------

The {{XRQuadLayerInit}} dictionary represents a set of configurable values that describe how an {{XRQuadLayer}} is initialized.

<pre class="idl">
dictionary XRQuadLayerInit : XRLayerInit {
  XRRigidTransform? transform;
  float width = 1.0;
  float height = 1.0;
  boolean isStatic = false;
};
</pre>

XRCylinderLayerInit {#xrcylinderlayerinit}
-------------------

The {{XRCylinderLayerInit}} dictionary represents a set of configurable values that describe how an {{XRCylinderLayer}} is initialized.

<pre class="idl">
dictionary XRCylinderLayerInit : XRLayerInit {
  XRRigidTransform? transform;
  float radius = 2.0;
  float centralAngle = 0.78539;
  float aspectRatio = 2.0;
  boolean isStatic = false;
};
</pre>

The default value of {{XRCylinderLayerInit/centralAngle}} is π / 4.

XREquirectLayerInit {#xrequirectlayerinit}
-------------------

The {{XREquirectLayerInit}} dictionary represents a set of configurable values that describe how an {{XREquirectLayer}} is initialized.

<pre class="idl">
dictionary XREquirectLayerInit : XRLayerInit {
  XRRigidTransform? transform;
  float radius = 0;
  float centralHorizontalAngle = 6.28318;
  float upperVerticalAngle = 1.570795;
  float lowerVerticalAngle = -1.570795;
  boolean isStatic = false;
};
</pre>

The default value of {{XREquirectLayerInit/centralHorizontalAngle}} is 2π.
The default value of {{XREquirectLayerInit/upperVerticalAngle}} is π/2.
The default value of {{XREquirectLayerInit/lowerVerticalAngle}} is -π/2.

XRCubeLayerInit {#xrcubelayerinit}
-------------------

The {{XRCubeLayerInit}} dictionary represents a set of configurable values that describe how an {{XRCubeLayer}} is initialized.

<pre class="idl">
dictionary XRCubeLayerInit : XRLayerInit {
  DOMPointReadOnly? orientation;
  boolean isStatic = false;
};
</pre>

XRWebGLBinding {#XRWebGLBindingtype}
-------------------
The {{XRWebGLBinding}} object is used to create layers that have a GPU backend.

<pre class="idl">
interface XRWebGLBinding {
  constructor(XRSession session, XRWebGLRenderingContext context);

  readonly attribute double nativeProjectionScaleFactor;

  XRProjectionLayer createProjectionLayer(XRTextureType textureType,
                                          optional XRProjectionLayerInit init);
  XRQuadLayer createQuadLayer(XRTextureType textureType,
                              optional XRQuadLayerInit init);
  XRCylinderLayer createCylinderLayer(XRTextureType textureType,
                                      optional XRCylinderLayerInit init);
  XREquirectLayer createEquirectLayer(XRTextureType textureType,
                                      optional XREquirectLayerInit init);
  XRCubeLayer createCubeLayer(optional XRCubeLayerInit init);

  XRWebGLSubImage getSubImage(XRCompositionLayer layer, XRFrame frame, optional XREye eye = "none");
  XRWebGLSubImage getViewSubImage(XRProjectionLayer layer, XRView view);
};
</pre>

ISSUE: the init dictionaries shouldn't be optional. This is bikeshed issue 1566.

Each {{XRWebGLBinding}} has a <dfn dfn-for="XRWebGLBinding">context</dfn> object of type {{XRWebGLRenderingContext}} which is an instance
of either a {{WebGLRenderingContext}} or a {{WebGL2RenderingContext}}.

Each {{XRWebGLBinding}} has an associated <dfn dfn-for="XRWebGLBinding">session</dfn>, which is the
{{XRSession}} it was created with.

NOTE: It is possible to create more than one {{XRWebGLBinding}}. Any layer created with an instance of {{XRWebGLBinding}} can
be used with another instance of {{XRWebGLBinding}} as long as both were created with the same [=XRWebGLBinding/session=] and the same
[=XRWebGLBinding/context=]. The lifetime of layers or instances of {{XRWebGLSubImage}} is not tied to the lifetime of the {{XRWebGLBinding}} that created them.

Each {{XRCompositionLayer}} created through {{XRWebGLBinding}} has an internal <dfn>colorTextures</dfn> array which is an |array| of {{WebGLTexture}} for color textures and
an internal <dfn>depthStencilTextures</dfn> which is an |array| of {{WebGLTexture}}</dfn> for depth/stencil textures.

<div class="algorithm" data-algorithm="construct-webgl-layer">

The <dfn constructor for="XRWebGLBinding">XRWebGLBinding(|session|, |context|)</dfn> constructor
MUST perform the following steps when invoked:

  1. Let |binding| be a [=new=] {{XRWebGLBinding}} in the [=relevant realm=] of |session|.
  1. If |session|'s [=ended=] value is <code>true</code>, throw an {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw an {{InvalidStateError}} and abort these steps.
  1. If |session| is not an [=immersive session=], throw an {{InvalidStateError}} and abort these steps.
  1. If |context|'s [=XR compatible=] boolean is <code>false</code>, throw an {{InvalidStateError}} and abort these steps.
  1. Initialize |binding|'s [=XRWebGLBinding/context=] to |context|.
  1. Initialize |binding|'s [=XRWebGLBinding/session=] to |session|.
  1. Return |binding|.

</div>

The {{nativeProjectionScaleFactor}} function returns the value that the |session|'s [=recommended WebGL framebuffer resolution=]
MUST be multiplied by to yield the |session|'s [=native WebGL framebuffer resolution=].

ISSUE: special case UA behavior if the size causes the layout to change (ie if the requested width exceeds a limit with {{XRLayerLayout/"stereo-left-right"}})

<div class="algorithm" data-algorithm="determine the layout attribute">

To <dfn>determine the layout attribute</dfn> using an {{XRTextureType}} |textureType|, an {{XRWebGLRenderingContext}} |context| and an {{XRLayerLayout}} |layout|, the user agent MUST run the following steps:
  1. If |context| is not an {{WebGL2RenderingContext}} and |textureType| is {{"texture-array"}}, throw {{TypeError}} and abort these steps.
  1. If |textureType| is {{"texture-array"}} and not all of the session’s [=view|views=] in the [=list of views=] have the same [=recommended WebGL texture resolution=], throw an {{NotSupportedError}} and abort these steps.
  1. If |layout| is {{XRLayerLayout/"mono"}}, return |layout| and abort these steps.
  1. If |layout| is {{XRLayerLayout/"default"}}, run the following steps:
    1. If the size of [=list of views=] is <code>1</code>, return {{XRLayerLayout/"mono"}} and abort these steps.
    1. If |textureType| is {{"texture-array"}}, return |layout| and abort these steps.
  1. If |layout| is {{XRLayerLayout/"default"}} or {{XRLayerLayout/"stereo"}}, run the following steps:
    1. If the user agent prefers {{XRLayerLayout/"stereo-left-right"}} layout, return {{XRLayerLayout/"stereo-left-right"}} and abort these steps.
    1. If the user agent prefers {{XRLayerLayout/"stereo-top-bottom"}} layout, return {{XRLayerLayout/"stereo-top-bottom"}} and abort these steps.
  1. return |layout|.

</div>

<div class="algorithm" data-algorithm="determine the maximum scalefactor">

To <dfn>determine the maximum scalefactor</dfn> using an {{XRSession}} |session|, an {{XRWebGLRenderingContext}} |context| and an {{XRLayerLayout}} |layout|, the user agent MUST run the following steps:
  1. Let |largest width| be the largest width of the [=recommended WebGL texture resolution=] from the |session|'s [=list of views=] excluding the [=first-person observer view=].
  1. Let |largest height| be the largest height of the [=recommended WebGL texture resolution=] from the |session|'s [=list of views=] excluding the [=first-person observer view=].
  1. If |layout| is {{XRLayerLayout/"stereo-left-right"}} layout, multiply |largest width| by <code>2</code>.
  1. If |layout| is {{XRLayerLayout/"stereo-top-bottom"}} layout, multiply |largest height| by <code>2</code>.
  1. Let |largest view dimension| be the largest of |largest width| or |largest height|.
  1. Let |largest texture dimension| be the largest dimension of a {{WebGLTexture}} created by |context|.
  1. return |largest texture dimension| divided by |largest view dimension|.

</div>

<div class="algorithm" data-algorithm="allocate color textures for projection layers">

To <dfn>allocate color textures for projection layers</dfn> using an {{XRProjectionLayer}} |layer|, an {{XRTextureType}} |textureType|, a boolean |alpha| and a float |scaleFactor|, the user agent MUST run the following steps:
  1. Let |array| be a [=new=] array in the [=relevant realm=] of |context|.
  1. Let |context| be |layer|'s [=XRCompositionLayer/context=].
  1. Let |session| be |layer|'s [=XRCompositionLayer/session=].
  1. Let |numViews| be the number of the |session|'s [=list of views=] excluding the [=first-person observer view=].
  1. Let |view| be the first entry in the |session|'s [=list of views=] that is not a [=first-person observer view=].
  1. Let |width| be the width of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
  1. Let |height| be the height of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/"mono"}} or {{XRLayerLayout/"default"}}:
        <dl class="switch">
        <dt> If |textureType| is {{"texture-array"}}:
          <dd> Initialize |array| with 1 [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a {{TEXTURE_2D_ARRAY}} texture with |numViews| layers using |context|, |alpha|, |width| and |height|.
          <dd> Return |array| and abort these steps.
        <dt> Otherwise
          <dd> For each |view| in the |session|'s [=list of views=]:
            1. If |view| is a [=first-person observer view=], continue.
            1. Let |width| be the width of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
            1. Let |height| be the height of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
            1. let |texture| be a [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a {{TEXTURE_2D}} texture with |context|, |alpha|, |width| and |height|.
            1. Append |texture| to |array|.
          <dd> Return |array| and abort these steps.
        </dl>
  1. If the session’s [=view|views=] in the [=list of views=] don't all have the same [=recommended WebGL texture resolution=] excluding the [=first-person observer view=], throw an {{NotSupportedError}} and abort these steps.
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/stereo-left-right}}, initialize |array| with 1 [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a |textureType| texture using |context| , |alpha|, |numViews| multiplied by |width| and |height|.
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/stereo-top-bottom}}, initialize |array| with 1 [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a |textureType| texture using |context| , |alpha|, |width| and |numViews| multiplied by |height|.
  1. return |array|.

</div>

<div class="algorithm" data-algorithm="allocate depth textures for projection layers">

To <dfn>allocate depth textures for projection layers</dfn> using an {{XRProjectionLayer}} |layer|, an {{XRTextureType}} |textureType|, a boolean |depth|, a boolean |stencil| and a float |scaleFactor|, the user agent MUST run the following steps:
  1. let |array| be a [=new=] array in the [=relevant realm=] of |context|.
  1. let |context| be |layer|'s [=XRCompositionLayer/context=].
  1. let |session| be |layer|'s [=XRCompositionLayer/session=].
  1. If |depth| and |stencil| are not set, return |array| and abort these steps.
  1. let |depthsupport| be true if |context| is a {{WebGL2RenderingContext}} or the {{WEBGL_depth_texture}} extension is enabled in |context|.
  1. If |depth| or |stencil| are set and |depthsupport| is false, throw {{TypeError}} and abort these steps.
  1. let |numViews| be the number of the |session|'s [=list of views=] excluding the [=first-person observer view=].
  1. Let |view| be the first entry in the |session|'s [=list of views=] that is not a [=first-person observer view=].
  1. Let |width| be the width of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
  1. Let |height| be the height of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/"mono"}} or {{XRLayerLayout/"default"}}:
        <dl class="switch">
        <dt> If |textureType| is {{"texture-array"}}:
          <dd> Initialize |array| with 1 [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a {{TEXTURE_2D_ARRAY}} texture with |numViews| layers using |context|, |stencil|, |width| and |height|.
          <dd> Return |array| and abort these steps.
        <dt> Otherwise
          <dd> For each |view| in the |session|'s [=list of views=]:
            1. If |view| is a [=first-person observer view=], continue.
            1. Let |width| be the width of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
            1. Let |height| be the height of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
            1. let |texture| be a [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a {{TEXTURE_2D}} texture with |context|, |stencil|, |width| and |height|.
            1. Append |texture| to |array|.
          <dd> Return |array| and abort these steps.
        </dl>
  1. If the session’s [=view|views=] in the [=list of views=] don't all have the same [=recommended WebGL texture resolution=] excluding the [=first-person observer view=], throw an {{NotSupportedError}} and abort these steps.
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/stereo-left-right}}, initialize |array| with 1 [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a |textureType| texture using |context| , |stencil|, |numViews| multiplied by |width| and |height|.
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/stereo-top-bottom}}, initialize |array| with 1 [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a |textureType| texture using |context| , |stencil|, |width| and |numViews| multiplied by |height|.
  1. return |array|.

</div>

<div class="algorithm" data-algorithm="allocate color texture for the first-person observer view">

To <dfn>allocate the color texture for the first-person observer view</dfn> using an {{XRProjectionLayer}} |layer|, an {{XRTextureType}} |textureType|, a boolean |alpha| and a float |scaleFactor|, the user agent MUST run the following steps:
  1. Let |context| be |layer|'s [=XRCompositionLayer/context=].
  1. Let |session| be |layer|'s [=XRCompositionLayer/session=].
  1. Let |view| be the [=first-person observer view=] from |session|'s [=list of views=].
  1. Let |width| be the width of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
  1. Let |height| be the height of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
  1. If |textureType| is {{XRTextureType/"texture-array"}}, return a [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a {{TEXTURE_2D_ARRAY}} texture with <code>1</code> layer using |context|, |alpha|, |width| and |height|.
  1. Return a [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a {{TEXTURE_2D}} texture using |context|, |alpha|, |width| and |height|.

</div>

<div class="algorithm" data-algorithm="allocate depth texture for the first-person observer view">

To <dfn>allocate the depth texture for the first-person observer view</dfn> using an {{XRProjectionLayer}} |layer|, an {{XRTextureType}} |textureType|, a boolean |depth|, a boolean |stencil| and a float |scaleFactor|, the user agent MUST run the following steps:
  1. Let |context| be |layer|'s [=XRCompositionLayer/context=].
  1. Let |session| be |layer|'s [=XRCompositionLayer/session=].
  1. If |depth| and |stencil| are not set, return <code>null</code> and abort these steps.
  1. let |depthsupport| be true if |context| is a {{WebGL2RenderingContext}} or the {{WEBGL_depth_texture}} extension is enabled in |context|.
  1. If |depth| or |stencil| are set and |depthsupport| is false, throw {{TypeError}} and abort these steps.
  1. Let |view| be the [=first-person observer view=] from |session|'s [=list of views=].
  1. Let |width| be the width of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
  1. Let |height| be the height of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
  1. If |textureType| is {{XRTextureType/"texture-array"}}, return a [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a {{TEXTURE_2D_ARRAY}} texture with <code>1</code> layer using |context|, |stencil|, |width| and |height| and abort these steps.
  1. Return a [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a {{TEXTURE_2D}} texture using |context|, |stencil|, |width| and |height|.

</div>

ISSUE: the scaleFactor needs to be recalculated for the first-person observer view.

<div class="algorithm" data-algorithm="allocate color textures">

To <dfn>allocate color textures</dfn> using an {{XRCompositionLayer}} |layer|, an {{XRTextureType}} |textureType| and an {{XRLayerInit}} |init|, the user agent MUST run the following steps:
  1. let |array| be a [=new=] array in the [=relevant realm=] of |context|.
  1. let |context| be |layer|'s [=XRCompositionLayer/context=].
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/"mono"}}:
        <dl class="switch">
        <dt> If |textureType| is {{"texture-array"}}:
          <dd> Initialize |array| with 1 [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of this |context| created as a {{TEXTURE_2D_ARRAY}} texture with 1 internal texture using |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
        <dt> Otherwise
          <dd> Initialize |array| with 1 [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a {{TEXTURE_2D}} texture with |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
        <dl>
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/"stereo"}}:
        <dl class="switch">
        <dt> If |textureType| is {{"texture-array"}}:
          <dd> Initialize |array| with 1 [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a {{TEXTURE_2D_ARRAY}} texture with 2 layers using |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
          <dd> Return |array| and abort these steps.
        <dt> Otherwise
          <dd> Initialize |array| with 2 [=new=] instances of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a {{TEXTURE_2D}} texture with |context| and |init|'s {{XRProjectionLayerInit/alpha}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
          <dd> Return |array| and abort these steps.
        </dl>
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/stereo-left-right}}, initialize |array| with 1 [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a |textureType| texture using |context| and |init|'s {{XRLayerInit/alpha}}, double of {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/stereo-top-bottom}}, initialize |array| with 1 [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a |textureType| texture using |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/viewPixelWidth}} and double of {{XRLayerInit/viewPixelHeight}} values.
  1. return |array|.

</div>

<div class="algorithm" data-algorithm="allocate depth textures">

To <dfn>allocate depth textures</dfn> using an {{XRCompositionLayer}} |layer|, an {{XRTextureType}} |textureType| and an {{XRLayerInit}} |init|, the user agent MUST run the following steps:
  1. let |array| be a [=new=] array in the [=relevant realm=] of |context|.
  1. let |context| be |layer|'s [=XRCompositionLayer/context=].
  1. If |init|'s {{XRLayerInit/depth}} and {{XRLayerInit/stencil}} are not set, return |array| and abort these steps.
  1. let |depthsupport| be true if |context| is a {{WebGL2RenderingContext}} or the {{WEBGL_depth_texture}} extension is enabled in |context|.
  1. If |init|'s {{XRLayerInit/depth}} or {{XRLayerInit/stencil}} are set and |depthsupport| is false, throw {{TypeError}} and abort these steps.
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/"mono"}}:
        <dl class="switch">
        <dt> If |textureType| is {{"texture-array"}}:
          <dd> Initialize |array| with 1 [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a {{TEXTURE_2D_ARRAY}} texture with 1 internal texture using |context| and |init|'s {{XRLayerInit/stencil}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
        <dt> Otherwise
          <dd> Initialize |array| with 1 [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a {{TEXTURE_2D}} texture with |context| and |init|'s {{XRLayerInit/stencil}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
        </dl>
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/"stereo"}}:
        <dl class="switch">
        <dt> If |textureType| is {{"texture-array"}}:
         <dd> Initialize |array| with 1 [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a {{TEXTURE_2D_ARRAY}} texture with 2 layers using |context| and |init|'s {{XRLayerInit/stencil}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
        <dd> Return |array| and abort these steps.
        <dt> Otherwise
          <dd> Initialize |array| with 2 [=new=] instances of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a {{TEXTURE_2D}} texture with |context| and |init|'s {{XRLayerInit/stencil}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
        <dd> Return |array| and abort these steps.
        </dl>
  1. If |layer|'s {{XRCompositionLayer/layout}}  is {{XRLayerLayout/stereo-left-right}}, initialize |array| with 1 [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a |textureType| texture using |context| and |init|'s {{XRLayerInit/stencil}}, double of {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
  1. If |layer|'s {{XRCompositionLayer/layout}}  is {{XRLayerLayout/stereo-top-bottom}}, initialize |array| with 1 [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of |context| created as a |textureType| texture using |context| and |init|'s {{XRLayerInit/stencil}}, {{XRLayerInit/viewPixelWidth}} and double of {{XRLayerInit/viewPixelHeight}} values.
  1. return |array|.

</div>

<div class="algorithm" data-algorithm="createProjectionLayerAlgo">
The <dfn method for="XRWebGLBinding">createProjectionLayer(XRTextureType |textureType|, optional XRProjectionLayerInit |init|)</dfn> method creates a new {{XRProjectionLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. Let |session| be [=this=] [=XRWebGLBinding/session=].
  1. Let |context| be [=this=] [=XRWebGLBinding/context=].
  1. Let |layer| be a [=new=] {{XRProjectionLayer}} in the [=relevant realm=] of [=this=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw {{InvalidStateError}} and abort these steps.
  1. Run [=intialize a composition layer=] on |layer| with |session| and |context|.
  1. Initialize |layer|'s [=XRCompositionLayer/isStatic=] to <code>false</code>.
  1. Initialize |layer|'s {{XRProjectionLayer/ignoreDepthValues}} as follows:
      <dl class="switch">
        <dt> If |init|'s {{XRProjectionLayerInit/depth}} value is <code>false</code> and the [=XR Compositor=] will make use of depth values
          <dd> Initialize |layer|'s {{XRProjectionLayer/ignoreDepthValues}} to <code>false</code>
        <dt> Otherwise
          <dd> Initialize |layer|'s {{XRProjectionLayer/ignoreDepthValues}} to <code>true</code>
      </dl>
  1. let |layout| be the result of [=determine the layout attribute|determining the layout attribute=] with |textureType|, |context| and {{XRLayerLayout/"default"}}.
  1. Let |maximum scalefactor| be the result of [=determine the maximum scalefactor|determining the maximum scalefactor=] with |session|, |context| and |layout|.
  1. If {{XRProjectionLayerInit/scaleFactor}} is larger than |maximum scalefactor|, set {{XRProjectionLayerInit/scaleFactor}} to |maximum scalefactor|.
  1. Initialize |layer|'s {{XRCompositionLayer/layout}} to |layout|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>true</code>.
  1. let |layer|'s [=colorTextures=] be the result of [=allocate color textures for projection layers|allocating color textures for projection layers=] with |layer|, |textureType|, |init|'s {{XRProjectionLayerInit/alpha}} and |init|'s {{XRProjectionLayerInit/scaleFactor}}.
  1. let |layer|'s [=depthStencilTextures=] be the result of [=allocate depth textures for projection layers|allocating depth textures for projection layers=] with |layer|, |textureType|, |init|'s {{XRProjectionLayerInit/depth}}, |init|'s {{XRProjectionLayerInit/stencil}} and |init|'s {{XRProjectionLayerInit/scaleFactor}}.
  1. Initialize the [=XRProjectionLayer/first-person observer color texture=] as follows:
      <dl class="switch">
        <dt> If the |session| was created with "[=feature descriptor/secondary-views=]" enabled
          <dd> Let [=XRProjectionLayer/first-person observer color texture=] be the result of [=allocate the color texture for the first-person observer view=] with |layer|, |textureType|, |init|'s {{XRProjectionLayerInit/alpha}} and |init|'s {{XRProjectionLayerInit/scaleFactor}}.
        <dt> Otherwise
          <dd> Let [=XRProjectionLayer/first-person observer color texture=] be <code>null</code>.
      </dl>
  1. Initialize the [=XRProjectionLayer/first-person observer depth texture=] as follows:
      <dl class="switch">
        <dt> If the |session| was created with "[=feature descriptor/secondary-views=]" enabled
          <dd> Let [=XRProjectionLayer/first-person observer depth texture=] be the result of [=allocate the depth texture for the first-person observer view=] with |layer|, |textureType|, |init|'s {{XRProjectionLayerInit/depth}}, |init|'s {{XRProjectionLayerInit/stencil}} and |init|'s {{XRProjectionLayerInit/scaleFactor}}.
        <dt> Otherwise
          <dd> Let [=XRProjectionLayer/first-person observer depth texture=] be <code>null</code>.
      </dl>
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. Return |layer|.

</div>

ISSUE: define "opaque" {{WebGLTexture}}

<div class="algorithm" data-algorithm="createQuadLayerAlgo">
The <dfn method for="XRWebGLBinding">createQuadLayer(XRTextureType |textureType|, XRQuadLayerInit |init|)</dfn> method creates a new {{XRQuadLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. Let |session| be [=this=] [=XRWebGLBinding/session=].
  1. If |session| was not created with "[=feature descriptor/layers=]" enabled, throw an {{NotSupportedError}} and abort these steps.
  1. Let |context| be [=this=] [=XRWebGLBinding/context=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw {{InvalidStateError}} and abort these steps.
  1. If |layout| is {{XRLayerLayout/"default"}}, throw {{TypeError}} and abort these steps.
  1. Let |layer| be a [=new=] {{XRQuadLayer}} in the [=relevant realm=] of [=this=].
  1. Run [=intialize a composition layer=] on |layer| with |session| and |context|.
  1. Run [=initialize a quad layer=] with |layer| and |init|.
  1. let |layout| be the result of [=determine the layout attribute|determining the layout attribute=] with |textureType|, |context| and |init|'s {{XRLayerInit/layout}}.
  1. Initialize |layer|'s {{XRCompositionLayer/layout}} to |layout|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>true</code>.
  1. let |layer|'s [=colorTextures=] be the result of [=allocate color textures|allocating color textures=] with |layer|, |textureType| and |init|.
  1. let |layer|'s [=depthStencilTextures=] be the result of [=allocate depth textures|allocating depth textures=] with |layer|, |textureType| and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

<div class="algorithm" data-algorithm="createCylinderLayerAlgo">
The <dfn method for="XRWebGLBinding">createCylinderLayer(XRTextureType |textureType|, XRCylinderLayerInit |init|)</dfn> method creates a new {{XRCylinderLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. Let |session| be [=this=] [=XRWebGLBinding/session=].
  1. If |session| was not created with "[=feature descriptor/layers=]" enabled, throw an {{NotSupportedError}} and abort these steps.
  1. Let |context| be [=this=] [=XRWebGLBinding/context=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw {{InvalidStateError}} and abort these steps.
  1. If |layout| is {{XRLayerLayout/"default"}}, throw {{TypeError}} and abort these steps.
  1. Let |layer| be a [=new=] {{XRCylinderLayer}} in the [=relevant realm=] of [=this=].
  1. Run [=intialize a composition layer=] on |layer| with |session| and |context|.
  1. Run [=initialize a cylinder layer=] with |layer| and |init|.
  1. let |layout| be the result of [=determine the layout attribute|determining the layout attribute=] with |textureType|, |context| and |init|'s {{XRLayerInit/layout}}.
  1. Initialize |layer|'s {{XRCompositionLayer/layout}} to |layout|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>true</code>.
  1. let |layer|'s [=colorTextures=] be the result of [=allocate color textures|allocating color textures=] with |layer|, |textureType| and |init|.
  1. let |layer|'s [=depthStencilTextures=] be the result of [=allocate depth textures|allocating depth textures=] with |layer|, |textureType| and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

<div class="algorithm" data-algorithm="createEquirectLayerAlgo">
The <dfn method for="XRWebGLBinding">createEquirectLayer(XRTextureType |textureType|, XREquirectLayerLayerInit |init|)</dfn> method creates a new {{XREquirectLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. Let |session| be [=this=] [=XRWebGLBinding/session=].
  1. If |session| was not created with "[=feature descriptor/layers=]" enabled, throw an {{NotSupportedError}} and abort these steps.
  1. Let |context| be [=this=] [=XRWebGLBinding/context=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw {{InvalidStateError}} and abort these steps.
  1. If |layout| is {{XRLayerLayout/"default"}}, throw {{TypeError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} is not an instance of type {{XRReferenceSpace}}, throw {{TypeError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} has a [=XRReferenceSpace/type=] of {{XRReferenceSpaceType/"viewer"}}, throw {{TypeError}} and abort these steps.
  1. Let |layer| be a [=new=] {{XREquirectLayer}} in the [=relevant realm=] of [=this=].
  1. Run [=intialize a composition layer=] on |layer| with |session| and |context|.
  1. Run [=initialize a equirect layer=] with |layer| and |init|.
  1. let |layout| be the result of [=determine the layout attribute|determining the layout attribute=] with |textureType|, |context| and |init|'s {{XRLayerInit/layout}}.
  1. Initialize |layer|'s {{XRCompositionLayer/layout}} to |layout|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>true</code>.
  1. let |layer|'s [=colorTextures=] be the result of [=allocate color textures|allocating color textures=] with |layer|, |textureType| and |init|.
  1. let |layer|'s [=depthStencilTextures=] be the result of [=allocate depth textures|allocating depth textures=] with |layer|, |textureType| and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

<div class="algorithm" data-algorithm="createCubeLayerAlgo">
The <dfn method for="XRWebGLBinding">createCubeLayer(XRCubeLayerInit |init|)</dfn> method creates a new {{XRCubeLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. Let |session| be [=this=] [=XRWebGLBinding/session=].
  1. If |session| was not created with "[=feature descriptor/layers=]" enabled, throw an {{NotSupportedError}} and abort these steps.
  1. Let |context| be [=this=] [=XRWebGLBinding/context=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is not a {{WebGL2RenderingContext}} context, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw {{InvalidStateError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} is not an instance of type {{XRReferenceSpace}}, throw {{TypeError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} has a [=XRReferenceSpace/type=] of {{XRReferenceSpaceType/"viewer"}}, throw {{TypeError}} and abort these steps.
  1. Let |layer| be a [=new=] {{XRCubeLayer}} in the [=relevant realm=] of [=this=].
  1. Run [=intialize a composition layer=] on |layer| with |session| and |context|.
  1. Let |layer|'s {{XRCubeLayer/space}} be the |init|'s {{XRLayerInit/space}}.
  1. Initialize |layer|'s [=XRCompositionLayer/isStatic=] to |init|'s {{XRCubeLayerInit/isStatic}}
  1. Initialize |layer|'s {{XRCubeLayer/orientation}} as follows:
    <dl class="switch">
      <dt class="switch">If |init|'s {{XRCubeLayerInit/orientation}} is set
      <dd> Let |layer|'s {{XRCubeLayer/orientation}} be the result of running {{DOMPointReadOnly/fromPoint}} with |init|'s {{XRCubeLayerInit/orientation}}.
      <dt> Otherwise
      <dd> Let |layer|'s {{XRCubeLayer/orientation}} be a [=new=] {{DOMPointReadOnly}} in the [=relevant realm=] of [=this=].
    </dl>
  1. let |layout| be |init|'s {{XRLayerInit/layout}}.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>true</code>.
  1. If |layout| is {{XRLayerLayout/"default"}} or {{XRLayerLayout/"stereo-left-right"}} or {{XRLayerLayout/"stereo-top-bottom"}}, throw {{TypeError}} and abort these steps.
  1. Let |layer|'s [=colorTextures=] be a [=new=] array in the [=relevant realm=] of this {{XRCubeLayer}}.
  1. Initialize |layer|'s [=colorTextures=] as follows, based on the value of |layout|:
    <dl class="switch">
      <dt> {{XRLayerLayout/"mono"}}:
        <dd> Initialize [=colorTextures=] with 1 [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of this {{XRCubeLayer}} created as a {{TEXTURE_CUBE_MAP}} texture with |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
      <dt> Otherwise
        <dd> Initialize [=colorTextures=] with 2 [=new=] instances of {{WebGLTexture}} in the [=relevant realm=] of this {{XRCubeLayer}} created as a {{TEXTURE_CUBE_MAP}} texture with |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
    </dl>
  1. Let |layer|'s [=depthStencilTextures=] be a [=new=] array in the [=relevant realm=] of this {{XRCubeLayer}}.
  1. If |init|'s {{XRLayerInit/depth}} and {{XRLayerInit/stencil}} are set, initialize |layer|'s [=depthStencilTextures=] as follows:
    <dl class="switch">
      <dt> If |context| is not a {{WebGL2RenderingContext}} and the {{WEBGL_depth_texture}} extension is not enabled in |context|.
        <dd> Throw {{TypeError}} and abort these steps.
      <dt> Else if |layout| is {{XRLayerLayout/"mono"}}:
        <dd> Initialize [=depthStencilTextures=] with 1 [=new=] instance of {{WebGLTexture}} in the [=relevant realm=] of this {{XRCubeLayer}} created as a {{TEXTURE_CUBE_MAP}} texture with |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
      <dt> Otherwise
        <dd> Initialize [=depthStencilTextures=] with 2 [=new=] instances of {{WebGLTexture}} in the [=relevant realm=] of this {{XRCubeLayer}} created as a {{TEXTURE_CUBE_MAP}} texture with |context| and |init|'s {{XRLayerInit/alpha}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
    </dl>
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

ISSUE: Define how cubemap sizes are determined.

ISSUE: How should space be handled. Can you walk to the edge of a cubemap?

ISSUE: determine the initial state of {{XRCubeLayer/orientation}}.

<div class="algorithm" data-algorithm="validate the state of the XRWebGLSubImage creation function">

To <dfn>validate the state of the XRWebGLSubImage creation function</dfn> of an {{XRWebGLBinding}} |binding| with parameters of {{XRCompositionLayer}} |layer| and {{XRFrame}} |frame|, the user agent MUST run the following steps:
  1. If |frame|'s {{XRFrame/session}} is not equal to |layer|'s [=XRCompositionLayer/session=], return <code>false</code> and abort these steps.
  1. If |frame|'s [=XRFrame/active=] boolean is <code>false</code>, return <code>false</code> and abort these steps.
  1. If |frame|'s [=XRFrame/animationFrame=] boolean is <code>false</code>, return <code>false</code> and abort these steps.
  1. If |binding|'s [=XRWebGLBinding/session=] is not equal to |layer|'s [=XRCompositionLayer/session=], return <code>false</code> and abort these steps.
  1. If |binding|'s [=XRWebGLBinding/context=] is not equal to |layer|'s [=XRCompositionLayer/context=], return <code>false</code> and abort these steps.
  1. If the |layer|'s [=colorTextures=] array is empty or missing, return <code>false</code> and abort these steps.
  1. If the |layer|'s [=XRCompositionLayer/isStatic=] is <code>true</code> and |layer|'s {{XRCompositionLayer/needsRedraw}} is <code>false</code>, return <code>false</code> and abort these steps.
  1. return <code>true</code>.

</div>

<div class="algorithm" data-algorithm="initialize the viewport">

To <dfn>initialize the viewport</dfn> of an {{XRViewport}} |viewport| with a {{WebGLTexture}} |texture|, a {{XRLayerLayout}}
|layout|, an integer |offset| and a integer |num|, the user agent MUST run the following steps:
  1. Set |viewport|'s {{XRViewport/x}} to <code>0</code>.
  1. Set |viewport|'s {{XRViewport/y}} to <code>0</code>.
  1. Set |viewport|'s {{XRViewport/width}} to the pixel width of |texture|.
  1. Set |viewport|'s {{XRViewport/height}} to the pixelh eight of |texture|.
  1. Update |viewport| as follows:
    <dl class="switch">
      <dt class="switch">If |layout| is {{XRLayerLayout/"stereo-left-right"}}:
        <dd>Set |viewport|'s {{XRViewport/x}} to the pixel width of |texture| multiplied by |offset| and divided by |num|.
        <dd>Set |viewport|'s {{XRViewport/width}} to half the pixel width of |subimage|'s |texture| divided by |num|.
      <dt class="switch">Else if |layout| is {{XRLayerLayout/"stereo-top-bottom"}}:
        <dd>Set |viewport|'s {{XRViewport/y}} to the pixel height of |texture| multiplied by |offset| and divided by |num|.
        <dd>Set |viewport|'s {{XRViewport/height}} to the pixel height of |subimage|'s |texture| divided by |num|.
    </dl>

</div>

<div class="algorithm" data-algorithm="getSubImageAlgo">
The <dfn method for="XRWebGLBinding">getSubImage(XRCompositionLayer |layer|, XRFrame |frame|, optional XREye |eye| = {{XREye/"none"}})</dfn> method creates a new {{XRWebGLSubImage}}.

When this method is invoked on an {{XRWebGLBinding}} |binding|, it MUST run the following steps:

  1. Initialize |subimage| as follows:
    <dl class="switch">
      <dt> If {{XRWebGLBinding/getSubImage()}} was called previously with the same |binding|, |layer| and |eye|, the user agent MAY:
        <dd> Let |subimage| be the same {{XRWebGLSubImage}} object as returned by an earlier call with the same arguments.
      <dt> Otherwise
        <dd> Let |subimage| be a [=new=] {{XRWebGLSubImage}} in the [=relevant realm=] of [=this=].
        <dd> Let |subimage|'s {{XRSubImage/viewport}} be a [=new=] {{XRViewport}} in the [=relevant realm=] of [=this=].
    </dl>
  1. If |layer|'s type is {{XRProjectionLayer}}, throw a {{TypeError}} and abort these steps.
  1. If |layer|'s {{XRCompositionLayer/layout}} attribute is {{XRLayerLayout/"default"}}, throw a {{TypeError}} and abort these steps.
  1. Let |index| be <code>0</code>.
  1. If |layer|'s {{XRCompositionLayer/layout}} attribute is {{XRLayerLayout/"stereo"}}:
    1. If |eye| is {{XREye/"none"}}, throw a {{TypeError}} and abort these steps.
    1. If |eye| is {{XREye/"right"}}, set |index| to <code>1</code>.
  1. If [=validate the state of the XRWebGLSubImage creation function=] with |layer| and |frame| is <code>false</code>, throw an {{InvalidStateError}} and abort these steps.
  1. Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} as follows:
    <dl class="switch">
      <dt class="switch">If the |layer| was created with a textureType of {{"texture-array"}}
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} with the first element of the |layer|'s [=colorTextures=] array.
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/imageIndex}} with |index|.
      <dt> Otherwise
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} with the element at offset |index| of the |layer|'s [=colorTextures=] array.
      </dl>
    </dl>
  1. Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} as follows:
    <dl class="switch">
      <dt class="switch">If the |layer|'s [=depthStencilTextures=] is an empty array.
        <dd> Continue to the next entry.
      <dt> Else if the |layer| was created with a textureType of {{"texture-array"}}
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with the first element of |layer|'s [=depthStencilTextures=] array.
      <dt> Otherwise
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with the element at offset |index| of the |layer|'s [=depthStencilTextures=] array.
      </dl>
  1. Set |subimage|'s {{XRWebGLSubImage/textureWidth}} to the pixel width of |subimage|'s {{XRWebGLSubImage/colorTexture}}.
  1. Set |subimage|'s {{XRWebGLSubImage/textureHeight}} to the pixel height of |subimage|'s {{XRWebGLSubImage/colorTexture}}.
  1. Let |index| be <code>0</code>.
  1. If |eye| is {{XREye/"right"}}, set |index| to <code>1</code>.
  1. Let |num| be <code>1</code>.
  1. If |eye| is not {{XREye/"none"}} and |layer|'s {{XRCompositionLayer/layout}} attribute is {{XRLayerLayout/"stereo-left-right"}} or {{XRLayerLayout/"stereo-top-bottom"}}, set |num| to <code>2</code>.
  1. Run [=initialize the viewport=] on |subimage|'s {{XRSubImage/viewport}} with |subimage|'s {{XRWebGLSubImage/colorTexture}}, |layer|'s {{XRCompositionLayer/layout}}, |index| and |num|.
  1. [=Queue a task=] to set {{XRCompositionLayer/needsRedraw}} to <code>false</code>.
  1. return |subimage|.

</div>

<div class="algorithm" data-algorithm="getViewSubImageAlgo">
The <dfn method for="XRWebGLBinding">getViewSubImage(XRProjectionLayer |layer|, XRView |view|)</dfn> method creates a new {{XRWebGLSubImage}}.

When this method is invoked on an {{XRWebGLBinding}} |binding|, it MUST run the following steps:

  1. Initialize |subimage| as follows:
    <dl class="switch">
      <dt> If {{XRWebGLBinding/getViewSubImage()}} was called previously with the same |binding|, |layer| and |view|, the user agent MAY:
        <dd> Let |subimage| be the same {{XRWebGLSubImage}} object as returned by an earlier call with the same arguments.
      <dt> Otherwise
        <dd> Let |subimage| be a [=new=] {{XRWebGLSubImage}} in the [=relevant realm=] of [=this=].
        <dd> Let |subimage|'s {{XRSubImage/viewport}} be a [=new=] {{XRViewport}} in the [=relevant realm=] of [=this=].
    </dl>
  1. Let |frame| be |view|'s {{frame}}.
  1. Let |session| be [=this=] [=XRWebGLBinding/session=].
  1. If [=validate the state of the XRWebGLSubImage creation function=] with |layer| and |frame| is <code>false</code>, throw an {{InvalidStateError}} and abort these steps.
  1. Initialize |index| as follows:
    <dl class="switch">
      <dt class="switch">If |view| is the [=first-person observer view=] from |session|'s [=list of views=]
        <dd>Let |index| be <code>0</code>.
      <dt> Otherwise
        <dd>Let |index| be the offset of |view|'s [=view=] in |session|'s [=list of views=] excluding the [=first-person observer view=].
    </dl>
  1. Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} as follows:
    <dl class="switch">
      <dt class="switch">If |view| is the [=first-person observer view=] from |session|'s [=list of views=]
        <dd>Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} with the [=XRProjectionLayer/first-person observer color texture=].
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/imageIndex}} with <code>0</code>.
      <dt> Else if the |layer| was created with a textureType of {{"texture-array"}}
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} with the first element of the |layer|'s [=colorTextures=] array.
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/imageIndex}} with |index|.
      <dt> Otherwise
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} with the element at offset |index| of the |layer|'s [=colorTextures=] array.
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/imageIndex}} with <code>0</code>.
    </dl>
  1. Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} as follows:
    <dl class="switch">
      <dt class="switch">If |view| is the [=first-person observer view=] from |session|'s [=list of views=]
        <dd>Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} with the [=XRProjectionLayer/first-person observer depth texture=].
      <dt>Else if the |layer|'s [=depthStencilTextures=] is an empty array.
        <dd> Continue to the next entry.
      <dt> Else if the |layer| was created with a textureType of {{"texture-array"}}
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with the first element of |layer|'s [=depthStencilTextures=] array.
      <dt> Otherwise
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with the element at offset |index| of the |layer|'s [=depthStencilTextures=] array.
    </dl>
  1. Set |subimage|'s {{XRWebGLSubImage/textureWidth}} to the pixel width of |subimage|'s {{XRWebGLSubImage/colorTexture}}.
  1. Set |subimage|'s {{XRWebGLSubImage/textureHeight}} to the pixel height of |subimage|'s {{XRWebGLSubImage/colorTexture}}.
  1. Run [=initialize the viewport=] on |subimage|'s {{XRSubImage/viewport}} with |subimage|'s {{XRWebGLSubImage/colorTexture}}, |layer|'s {{XRCompositionLayer/layout}}, |index| and the number of the |session|'s [=list of views=].
  1. Set {{XRCompositionLayer/needsRedraw}} to <code>false</code>.
  1. return |subimage|

</div>

When an {{XRLayer}} is a member of the {{XRRenderState/layers}} array, it MUST be presented to the [=immersive XR device=] immediately after
an [=XR animation frame=] completes, but only if at least one of the following has occurred since the previous [=XR animation frame=]:

  - The {{XRLayer}} was added to {{XRRenderState/layers}} since the previous [=XR animation frame=].
  - {{XRLayer}} is an {{XRWebGLLayer}} and {{clear}}, {{drawArrays}}, {{drawElements}}, or any other rendering operation which similarly affects the framebuffer's color values has been called while the [=opaque framebuffer=] is the currently bound framebuffer of the {{WebGLRenderingContext}} associated with the {{XRWebGLLayer}}.
  - {{XRLayer}} is an {{XRCompositionLayer}} and {{XRWebGLBinding/getSubImage()}} or {{XRWebGLBinding/getViewSubImage()}} was called and any rendering operation has been called that affects the color value of the {{XRWebGLSubImage/colorTexture}} texture.

Before the [=opaque framebuffer=] or {{XRWebGLSubImage/colorTexture}} texture are presented to the [=immersive XR device=] the user agent MUST ensure that all rendering operations have been flushed.

Video layer creation {#videolayer}
====================

XRMediaLayerInit {#xrmedialayerinittype}
----------------
The {{XRMediaLayerInit}} dictionary represents a set of configurable values that describe how an {{XRCompositionLayer}} containing a video
is initialized.

<pre class="idl">
dictionary XRMediaLayerInit {
  required XRSpace space;
  XRLayerLayout layout = "mono";
  boolean invertStereo = false;
};
</pre>

The <dfn dict-member for="XRMediaLayerInit">space</dfn> attribute defines the spatial relationship with the user’s physical environment.

The <dfn dict-member for="XRMediaLayerInit">layout</dfn> attribute defines the layout of the video in the {{XRCompositionLayer}}.

The <dfn dict-member for="XRMediaLayerInit">invertStereo</dfn> attribute defines if the natural location of each view in the video
should be inverted.

XRMediaBinding {#xrmediabindingtype}
--------------
The {{XRMediaBinding}} object is used to create layers that display the content of an {{HTMLVideoElement}}.

<pre class="idl">
interface XRMediaBinding {
  constructor(XRSession session);

  XRQuadLayer createQuadVideoLayer(HTMLVideoElement video,
                                   optional XRMediaLayerInit init = {});
  XRCylinderLayer createCylinderVideoLayer(HTMLVideoElement video,
                                           optional XRMediaLayerInit init = {});
  XREquirectLayer createEquirectVideoLayer(HTMLVideoElement video,
                                           optional XRMediaLayerInit init = {});
};

</pre>

Each {{XRMediaBinding}} has an associated <dfn dfn-for="XRMediaBinding">session</dfn>, which is the
{{XRSession}} it was created with.

NOTE: It is possible to create more than one {{XRMediaBinding}}. The lifetime of a layer is not tied
to the lifetime of the {{XRMediaBinding}} that created it.

Each layer created through {{XRMediaBinding}} has an internal {{HTMLVideoElement}} [=XRCompositionLayer/media=].
If the layer is part of the session's {{XRSession/renderState}}, it will display the current frame of the video. The
layer is update at the native framerate of the [=/XR device=] or the video, whichever is less.

NOTE: only the video frames will be displayed in the layer. Video controls should be implemented by the author and must
be drawn in another layer.

ISSUE: more clarification is needed on how the video is blitted to the layers.

<div class="algorithm" data-algorithm="render-media-layer">
When an {{XRCompositionLayer}} |layer| with a {{HTMLVideoElement}} |media| needs to be rendered, the user agent
MUST run the following steps:
  1. Let |usability| be the result of [=check the usability of the image argument|checking the usability of=] |media|.
  1. If |usability| is <code>bad</code>, then fill the |layer| with opaque black and abort these steps.
  1. Fill the |layer| with the content of the |media| element.

<!--
-> maybe this is needed later
  1. Render the |layer| as follows:
    <dl class="switch">
      <dt class="switch">If the |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/"mono"}}
      <dd> Fill the |layer| with the
      <dt> Else if the |layer| was created with a textureType of {{"texture-array"}}
      <dd> Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with the element at offset |index| of the |layer|'s [=depthStencilTextures=] array.
      <dt> Otherwise
      <dd> Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with the element of the |layer|'s [=depthStencilTextures=] array that corresponds to the |view|.
    </dl>
-->
</div>

ISSUE: add a better algorithm to describe the drawing.

<div class="algorithm" data-algorithm="construct-media-binding">

The <dfn constructor for="XRMediaBinding">XRMediaBinding(XRSession |session|)</dfn> constructor
MUST perform the following steps when invoked:

  1. If |session|'s [=ended=] value is <code>true</code>, throw an {{InvalidStateError}} and abort these steps.
  1. If |session| is not an [=immersive session=], throw an {{InvalidStateError}} and abort these steps.
  1. Let |binding| be a [=new=] {{XRMediaBinding}}in the [=relevant realm=] of |session|.
  1. Initialize |binding|'s [=XRMediaBinding/session=] to |session|.
  1. Return |binding|.

</div>

<div class="algorithm" data-algorithm="createMediaQuadLayerAlgo">
The <dfn method for="XRMediaBinding">createQuadLayer(HTMLVideoElement |video|, optional XRMediaLayerInit |init|)</dfn> method creates a new {{XRQuadLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. If the device does not support the creation of an {{XRQuadLayer}}, throw an {{NotSupportedError}} and abort these steps.
  1. Let |session| be [=this=] [=XRMediaBinding/session=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. Let |layer| be a [=new=] {{XRQuadLayer}} in the [=relevant realm=] of [=this=].
  1. Run [=intialize a composition layer=] on |layer| with |session|.
  1. Initialize |layer|'s [=XRCompositionLayer/media=] to |video|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>false</code>.
  1. Run [=initialize a quad layer=] with |layer| and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

<div class="algorithm" data-algorithm="createMediaCylinderLayerAlgo">
The <dfn method for="XRMediaBinding">createCylinderLayer(HTMLVideoElement |video|, optional XRMediaLayerInit |init|)</dfn> method creates a new {{XRCylinderLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. If the device does not support the creation of an {{XRCylinderLayer}}, throw an {{NotSupportedError}} and abort these steps.
  1. Let |session| be [=this=] [=XRMediaBinding/session=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. Let |layer| be a [=new=] {{XRCylinderLayer}} in the [=relevant realm=] of [=this=].
  1. Run [=intialize a composition layer=] on |layer| with |session|.
  1. Initialize |layer|'s [=XRCompositionLayer/media=] to |video|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>false</code>.
  1. Run [=initialize a cylinder layer=] with |layer| and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

<div class="algorithm" data-algorithm="createMediaEquirectLayerAlgo">
The <dfn method for="XRMediaBinding">createEquirectLayer(HTMLVideoElement |video|, optional XRMediaLayerInit |init|)</dfn> method creates a new {{XREquirectLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. If the device does not support the creation of an {{XREquirectLayer}}, throw an {{NotSupportedError}} and abort these steps.
  1. Let |session| be [=this=] [=XRMediaBinding/session=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} is not an instance of type {{XRReferenceSpace}}, throw {{InvalidStateError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} has a [=XRReferenceSpace/type=] of {{XRReferenceSpaceType/"viewer"}}, throw {{InvalidStateError}} and abort these steps.
  1. Let |layer| be a [=new=] {{XREquirectLayer}} in the [=relevant realm=] of [=this=].
  1. Run [=intialize a composition layer=] on |layer| with |session|.
  1. Initialize |layer|'s [=XRCompositionLayer/media=] to |video|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>false</code>.
  1. Run [=initialize a equirect layer=] with |layer| and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

ISSUE: define how the {{XREquirectLayer}}'s parameters affect the video display.

Events {#events}
======

XRLayerEvent {#xrlayerevent-interface}
--------------

{{XRLayerEvent}} is fired to indicate changes to the state of an {{XRLayer}}.

<pre class="idl">
[SecureContext, Exposed=Window]
interface XRLayerEvent : Event {
  constructor(DOMString type, XRLayerEventInit eventInitDict);
  [SameObject] readonly attribute XRLayer layer;
};

dictionary XRLayerEventInit : EventInit {
  required XRLayer layer;
};
</pre>

The <dfn attribute for="XRLayerEvent">layer</dfn> attribute indicates the {{XRLayer}} that generated the event.

Event Types {#event-types}
-----------

The user agent MUST provide the following new events. Registration for and firing of the events must follow the usual behavior of DOM4 Events.

The user agent MAY fire a <dfn event for="XRLayer">redraw</dfn> event on the {{XRLayer}} object when [=the underlying resources of a layer are lost=] or
when the [=XR Compositor=] can no longer reproject the layer.

The author SHOULD redraw the content of the layer at the next [=XR animation frame=]. The event must be of type {{XRLayerEvent}}.

WebXR Device API Integration {#webxrintegration}
============================

XRRenderState changes {#xrrenderstatechanges}
---------------------
This module extends the {{XRRenderStateInit}} and {{XRRenderState}} interfaces with a new optional array {{XRRenderStateInit/layers}} containing
instances of {{XRLayer}}.

<pre class="idl">
[SecureContext, Exposed=Window] partial interface XRRenderState {
  [SameObject] readonly attribute FrozenArray&lt;XRLayer&gt; layers;
};
</pre>

The <dfn attribute for="XRRenderState">layers</dfn> attribute returns an array containing
the instances of {{XRLayer}} that are displayed by the [=XR Compositor=].

<div class="algorithm" data-algorithm="initialize-renderstate-for-layers">
This module replaces the steps given by [=initialize the render state=]. Instead when an {{XRRenderState}} object |state|
is created for an {{XRSession}} |session|, the user agent MUST <dfn dfn-for="layers">initialize the render state</dfn> by running the following steps:
  1. Initialize |state| by running the original steps to [=initialize the render state=].
  1. Initialize |state|'s {{XRRenderState/layers}} with a [=new=] empty array in the [=relevant realm=] of |session|.

</div>

updateRenderState changes {#updaterenderstatechanges}
-------------------------

<div class="algorithm" data-algorithm="update-layers-state-for-layers">

This module replaces the steps given by "[=update the pending layers state=]" from the WebXR specification. Instead when the user agent will
<dfn dfn-for="layers">update the pending layers state</dfn> with {{XRSession}} |session| and {{XRRenderStateInit}} |newState|, it must run the following steps:
  1. If |newState|'s {{XRRenderStateInit/baseLayer}} is set:
    1. If the |session| was created with "[=feature descriptor/layers=]" enabled, throw an {{NotSupportedError}} and abort these steps.
    1. If |newState|'s {{XRRenderStateInit/layers}} is not empty, throw a {{TypeError}} and abort these steps.
  1. If |newState|'s {{XRRenderStateInit/layers}} contains duplicate instances, throw an {{TypeError}} and abort these steps.
  1. For each |layer| in |newState|'s {{XRRenderStateInit/layers}}:
    1. If |layer| is an {{XRCompositionLayer}} and |layer|'s [=XRCompositionLayer/session=] is different from |session|, throw an {{TypeError}} and abort these steps.
    1. If |layer| is an {{XRWebGLLayer}} and |layer|'s [=XRWebGLLayer/session=] is different from |session|, throw an {{TypeError}} and abort these steps.
  1. Let |activeState| be |session|'s [=active render state=].
  1. If |session|'s [=pending render state=] is <code>null</code>, set it to a copy of |activeState|.
  1. If |newState|'s {{XRRenderStateInit/layers}} array is set, set |session|'s [=pending render state=]'s {{XRRenderState/layers}} to |newState|'s {{XRRenderStateInit/layers}}.

</div>

XRCompositor changes {#xrcompositorchanges}
---------------------
The [=XR Compositor=] MUST be extended so all {{XRLayer}} instances from the {{XRRenderState/layers}} array are composited
at the same time. All other requirements for [=XR Compositor|WebXR=] MUST continue to apply.

If the [=XR Compositor=] is rendering to a [=view=] with an {{XREye}} of {{XREye/"none"}} and drawing an {{XRCompositionLayer}} which is NOT an
{{XRProjectionLayer}} and does NOT have a {{XRCompositionLayer/layout}} of {{XRLayerLayout/"mono"}}, the [=XR Compositor=] MUST render that layer
as if the [=view=] had an {{XREye}} of {{XREye/"left"}}.

NOTE: This means that the side for the right eye of the layer is ignored. This enables authors to use the same assets for stereoscopic and
monoscopic devices.

XRView changes {#xrviewchanges}
--------------
Each [=view=] MUST define a <dfn ignore=''>recommended WebGL texture resolution</dfn> which represents a best estimate of the WebGL texture
resolution large enough to contain the view.

Animation frames changes {#animationframeschanges}
------------------------

<div class="algorithm" data-algorithm="update-check-layers-state">
This module replaces the steps given by "[=check the layers state=]" from the WebXR specification. Instead to <dfn>check the layers state</dfn>
with {{XRSession/renderState}} |state|, the user agent MUST run the following steps:

  1. If |state|'s {{XRRenderState/baseLayer}} is not <code>null</code>, return <code>true</code>.
  1. If |state|'s {{XRRenderStateInit/layers}} is not empty, return <code>true</code>.
  1. return <code>false</code>.

</div>

Security and Privacy Considerations {#security}
===============================================

Timing of the composition {#xrcompositiontiming}
-------------------------

Composition timing MUST be independent of the content that is rendered.
Moreover, content in a layer MUST not be observable in other layers.

If possible, composition of layers should happen outside the browser to reduce risk of timing attacks or other security vulnerabilities.
